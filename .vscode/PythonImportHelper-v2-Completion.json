[
    {
        "label": "rules",
        "importPath": "__init__",
        "description": "__init__",
        "isExtraImport": true,
        "detail": "__init__",
        "documentation": {}
    },
    {
        "label": "BasePlugin",
        "importPath": "pluginsystem",
        "description": "pluginsystem",
        "isExtraImport": true,
        "detail": "pluginsystem",
        "documentation": {}
    },
    {
        "label": "Listener",
        "importPath": "pluginsystem",
        "description": "pluginsystem",
        "isExtraImport": true,
        "detail": "pluginsystem",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "Surface",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "KEYDOWN",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "KEYUP",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "QUIT",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "event",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Window",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Window",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Label",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "Window",
        "importPath": "pygameui",
        "description": "pygameui",
        "isExtraImport": true,
        "detail": "pygameui",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "farmlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "farmlib",
        "description": "farmlib",
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "DictMapper",
        "importPath": "farmlib",
        "description": "farmlib",
        "isExtraImport": true,
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "__VERSION__",
        "importPath": "farmlib",
        "description": "farmlib",
        "isExtraImport": true,
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "PluginSystem",
        "importPath": "farmlib",
        "description": "farmlib",
        "isExtraImport": true,
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "__VERSION__",
        "importPath": "farmlib",
        "description": "farmlib",
        "isExtraImport": true,
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "PluginSystem",
        "importPath": "farmlib",
        "description": "farmlib",
        "isExtraImport": true,
        "detail": "farmlib",
        "documentation": {}
    },
    {
        "label": "pnoise",
        "importPath": "pnoise",
        "description": "pnoise",
        "isExtraImport": true,
        "detail": "pnoise",
        "documentation": {}
    },
    {
        "label": "DictMapper",
        "importPath": "dictmapper",
        "description": "dictmapper",
        "isExtraImport": true,
        "detail": "dictmapper",
        "documentation": {}
    },
    {
        "label": "FarmField",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "FarmTile",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "FarmObject",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "Seed",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "farmlib.farm",
        "description": "farmlib.farm",
        "isExtraImport": true,
        "detail": "farmlib.farm",
        "documentation": {}
    },
    {
        "label": "Player",
        "importPath": "farmlib.player",
        "description": "farmlib.player",
        "isExtraImport": true,
        "detail": "farmlib.player",
        "documentation": {}
    },
    {
        "label": "ImageLoader",
        "importPath": "farmlib.imageloader",
        "description": "farmlib.imageloader",
        "isExtraImport": true,
        "detail": "farmlib.imageloader",
        "documentation": {}
    },
    {
        "label": "Timer",
        "importPath": "farmlib.timer",
        "description": "farmlib.timer",
        "isExtraImport": true,
        "detail": "farmlib.timer",
        "documentation": {}
    },
    {
        "label": "ExpBar",
        "importPath": "farmlib.expbar",
        "description": "farmlib.expbar",
        "isExtraImport": true,
        "detail": "farmlib.expbar",
        "documentation": {}
    },
    {
        "label": "render_field",
        "importPath": "farmlib.renderfunctions",
        "description": "farmlib.renderfunctions",
        "isExtraImport": true,
        "detail": "farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_rain",
        "importPath": "farmlib.renderfunctions",
        "description": "farmlib.renderfunctions",
        "isExtraImport": true,
        "detail": "farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_seed_notify",
        "importPath": "farmlib.renderfunctions",
        "description": "farmlib.renderfunctions",
        "isExtraImport": true,
        "detail": "farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "draw_selected_seed",
        "importPath": "farmlib.renderfunctions",
        "description": "farmlib.renderfunctions",
        "isExtraImport": true,
        "detail": "farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "draw_tools",
        "importPath": "farmlib.renderfunctions",
        "description": "farmlib.renderfunctions",
        "isExtraImport": true,
        "detail": "farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "MarketWindow",
        "importPath": "farmlib.marketwindow",
        "description": "farmlib.marketwindow",
        "isExtraImport": true,
        "detail": "farmlib.marketwindow",
        "documentation": {}
    },
    {
        "label": "InventoryWindow",
        "importPath": "farmlib.inventorywindow",
        "description": "farmlib.inventorywindow",
        "isExtraImport": true,
        "detail": "farmlib.inventorywindow",
        "documentation": {}
    },
    {
        "label": "HelpWindow",
        "importPath": "farmlib.helpwindow",
        "description": "farmlib.helpwindow",
        "isExtraImport": true,
        "detail": "farmlib.helpwindow",
        "documentation": {}
    },
    {
        "label": "CorePlugin",
        "importPath": "farmlib.coreplugin",
        "description": "farmlib.coreplugin",
        "isExtraImport": true,
        "detail": "farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "GameManager",
        "importPath": "farmlib.gamemanager",
        "description": "farmlib.gamemanager",
        "isExtraImport": true,
        "detail": "farmlib.gamemanager",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "farm",
        "description": "farm",
        "isExtraImport": true,
        "detail": "farm",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "farm",
        "description": "farm",
        "isExtraImport": true,
        "detail": "farm",
        "documentation": {}
    },
    {
        "label": "objects",
        "importPath": "farm",
        "description": "farm",
        "isExtraImport": true,
        "detail": "farm",
        "documentation": {}
    },
    {
        "label": "FarmObject",
        "importPath": "farm",
        "description": "farm",
        "isExtraImport": true,
        "detail": "farm",
        "documentation": {}
    },
    {
        "label": "Seed",
        "importPath": "farm",
        "description": "farm",
        "isExtraImport": true,
        "detail": "farm",
        "documentation": {}
    },
    {
        "label": "Tooltip",
        "importPath": "farmlib.tooltip",
        "description": "farmlib.tooltip",
        "isExtraImport": true,
        "detail": "farmlib.tooltip",
        "documentation": {}
    },
    {
        "label": "Tooltip",
        "importPath": "tooltip",
        "description": "tooltip",
        "isExtraImport": true,
        "detail": "tooltip",
        "documentation": {}
    },
    {
        "label": "GameWindow",
        "importPath": "farmlib.gamewindow",
        "description": "farmlib.gamewindow",
        "isExtraImport": true,
        "detail": "farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Widget",
        "importPath": "widget",
        "description": "widget",
        "isExtraImport": true,
        "detail": "widget",
        "documentation": {}
    },
    {
        "label": "Widget",
        "importPath": "widget",
        "description": "widget",
        "isExtraImport": true,
        "detail": "widget",
        "documentation": {}
    },
    {
        "label": "Widget",
        "importPath": "widget",
        "description": "widget",
        "isExtraImport": true,
        "detail": "widget",
        "documentation": {}
    },
    {
        "label": "Widget",
        "importPath": "widget",
        "description": "widget",
        "isExtraImport": true,
        "detail": "widget",
        "documentation": {}
    },
    {
        "label": "Container",
        "importPath": "container",
        "description": "container",
        "isExtraImport": true,
        "detail": "container",
        "documentation": {}
    },
    {
        "label": "MenuWindow",
        "importPath": "farmlib.menuwindow",
        "description": "farmlib.menuwindow",
        "isExtraImport": true,
        "detail": "farmlib.menuwindow",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "gym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym",
        "description": "gym",
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ActionWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "RewardWrapper",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "envs",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "envs",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "envs",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "envs",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "envs",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "CustomSpaceError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "CustomSpaceError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "AlreadyPendingCallError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "ClosedEnvironmentError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "CustomSpaceError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "NoAsyncCallError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "AlreadyPendingCallError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "ClosedEnvironmentError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "NoAsyncCallError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "CustomSpaceError",
        "importPath": "gym.error",
        "description": "gym.error",
        "isExtraImport": true,
        "detail": "gym.error",
        "documentation": {}
    },
    {
        "label": "EzPickle",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "EzPickle",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "EzPickle",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "colorize",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "Car",
        "importPath": "gym.envs.box2d.car_dynamics",
        "description": "gym.envs.box2d.car_dynamics",
        "isExtraImport": true,
        "detail": "gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "closing",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "closing",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "closing",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "categorical_sample",
        "importPath": "gym.envs.toy_text.utils",
        "description": "gym.envs.toy_text.utils",
        "isExtraImport": true,
        "detail": "gym.envs.toy_text.utils",
        "documentation": {}
    },
    {
        "label": "categorical_sample",
        "importPath": "gym.envs.toy_text.utils",
        "description": "gym.envs.toy_text.utils",
        "isExtraImport": true,
        "detail": "gym.envs.toy_text.utils",
        "documentation": {}
    },
    {
        "label": "categorical_sample",
        "importPath": "gym.envs.toy_text.utils",
        "description": "gym.envs.toy_text.utils",
        "isExtraImport": true,
        "detail": "gym.envs.toy_text.utils",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "internal_env_relocation_map",
        "importPath": "gym.envs.__relocated__",
        "description": "gym.envs.__relocated__",
        "isExtraImport": true,
        "detail": "gym.envs.__relocated__",
        "documentation": {}
    },
    {
        "label": "AutoResetWrapper",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "OrderEnforcing",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TimeLimit",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "FlattenObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "FilterObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "FlattenObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "AtariPreprocessing",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "AutoResetWrapper",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "ClipAction",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "FlattenObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "FrameStack",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "AtariPreprocessing",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "GrayScaleObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "OrderEnforcing",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "RecordEpisodeStatistics",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "capped_cubic_video_schedule",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "RescaleAction",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "ResizeObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TimeAwareObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TimeLimit",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TransformObservation",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TransformReward",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "OrderEnforcing",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "TimeLimit",
        "importPath": "gym.wrappers",
        "description": "gym.wrappers",
        "isExtraImport": true,
        "detail": "gym.wrappers",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces.space",
        "description": "gym.spaces.space",
        "isExtraImport": true,
        "detail": "gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces.discrete",
        "description": "gym.spaces.discrete",
        "isExtraImport": true,
        "detail": "gym.spaces.discrete",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "gym.spaces",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Space",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "unflatten",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "NDArray",
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "isExtraImport": true,
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "pygame.event",
        "description": "pygame.event",
        "isExtraImport": true,
        "detail": "pygame.event",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "pygame.event",
        "description": "pygame.event",
        "isExtraImport": true,
        "detail": "pygame.event",
        "documentation": {}
    },
    {
        "label": "deprecation",
        "importPath": "gym.logger",
        "description": "gym.logger",
        "isExtraImport": true,
        "detail": "gym.logger",
        "documentation": {}
    },
    {
        "label": "deprecation",
        "importPath": "gym.logger",
        "description": "gym.logger",
        "isExtraImport": true,
        "detail": "gym.logger",
        "documentation": {}
    },
    {
        "label": "deprecation",
        "importPath": "gym.logger",
        "description": "gym.logger",
        "isExtraImport": true,
        "detail": "gym.logger",
        "documentation": {}
    },
    {
        "label": "deprecation",
        "importPath": "gym.logger",
        "description": "gym.logger",
        "isExtraImport": true,
        "detail": "gym.logger",
        "documentation": {}
    },
    {
        "label": "VIDEORESIZE",
        "importPath": "pygame.locals",
        "description": "pygame.locals",
        "isExtraImport": true,
        "detail": "pygame.locals",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "c_bool",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "CloudpickleWrapper",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "clear_mpi_env_vars",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "concatenate",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "create_empty_array",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "create_shared_memory",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "read_from_shared_memory",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "write_to_shared_memory",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "concatenate",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "create_empty_array",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "gym.vector.utils",
        "description": "gym.vector.utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils",
        "documentation": {}
    },
    {
        "label": "VectorEnv",
        "importPath": "gym.vector.vector_env",
        "description": "gym.vector.vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "VectorEnv",
        "importPath": "gym.vector.vector_env",
        "description": "gym.vector.vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "VectorEnv",
        "importPath": "gym.vector.vector_env",
        "description": "gym.vector.vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "batch_space",
        "importPath": "gym.vector.utils.spaces",
        "description": "gym.vector.utils.spaces",
        "isExtraImport": true,
        "detail": "gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "_BaseGymSpaces",
        "importPath": "gym.vector.utils.spaces",
        "description": "gym.vector.utils.spaces",
        "isExtraImport": true,
        "detail": "gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "_BaseGymSpaces",
        "importPath": "gym.vector.utils.spaces",
        "description": "gym.vector.utils.spaces",
        "isExtraImport": true,
        "detail": "gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "batch_space",
        "importPath": "gym.vector.utils.spaces",
        "description": "gym.vector.utils.spaces",
        "isExtraImport": true,
        "detail": "gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "gym.vector.utils.spaces",
        "description": "gym.vector.utils.spaces",
        "isExtraImport": true,
        "detail": "gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "pkgutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pkgutil",
        "description": "pkgutil",
        "detail": "pkgutil",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "video_recorder",
        "importPath": "gym.wrappers.monitoring",
        "description": "gym.wrappers.monitoring",
        "isExtraImport": true,
        "detail": "gym.wrappers.monitoring",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "RandomNumberGenerator",
        "importPath": "gym.utils.seeding",
        "description": "gym.utils.seeding",
        "isExtraImport": true,
        "detail": "gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "RandomNumberGenerator",
        "importPath": "gym.utils.seeding",
        "description": "gym.utils.seeding",
        "isExtraImport": true,
        "detail": "gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "SKIP_MUJOCO_WARNING_MESSAGE",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "skip_mujoco",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "spec_list",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "spec_list",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "SKIP_MUJOCO_WARNING_MESSAGE",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "skip_mujoco",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "spec_list",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "spec_list",
        "importPath": "tests.envs.spec_list",
        "description": "tests.envs.spec_list",
        "isExtraImport": true,
        "detail": "tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "registry",
        "importPath": "gym.envs.registration",
        "description": "gym.envs.registration",
        "isExtraImport": true,
        "detail": "gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "EnvSpec",
        "importPath": "gym.envs.registration",
        "description": "gym.envs.registration",
        "isExtraImport": true,
        "detail": "gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "check_env",
        "importPath": "gym.utils.env_checker",
        "description": "gym.utils.env_checker",
        "isExtraImport": true,
        "detail": "gym.utils.env_checker",
        "documentation": {}
    },
    {
        "label": "check_env",
        "importPath": "gym.utils.env_checker",
        "description": "gym.utils.env_checker",
        "isExtraImport": true,
        "detail": "gym.utils.env_checker",
        "documentation": {}
    },
    {
        "label": "generate_random_map",
        "importPath": "gym.envs.toy_text.frozen_lake",
        "description": "gym.envs.toy_text.frozen_lake",
        "isExtraImport": true,
        "detail": "gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "register",
        "importPath": "gym.envs",
        "description": "gym.envs",
        "isExtraImport": true,
        "detail": "gym.envs",
        "documentation": {}
    },
    {
        "label": "registration",
        "importPath": "gym.envs",
        "description": "gym.envs",
        "isExtraImport": true,
        "detail": "gym.envs",
        "documentation": {}
    },
    {
        "label": "registry",
        "importPath": "gym.envs",
        "description": "gym.envs",
        "isExtraImport": true,
        "detail": "gym.envs",
        "documentation": {}
    },
    {
        "label": "spec",
        "importPath": "gym.envs",
        "description": "gym.envs",
        "isExtraImport": true,
        "detail": "gym.envs",
        "documentation": {}
    },
    {
        "label": "cartpole",
        "importPath": "gym.envs.classic_control",
        "description": "gym.envs.classic_control",
        "isExtraImport": true,
        "detail": "gym.envs.classic_control",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "MissingKeysToAction",
        "importPath": "gym.utils.play",
        "description": "gym.utils.play",
        "isExtraImport": true,
        "detail": "gym.utils.play",
        "documentation": {}
    },
    {
        "label": "PlayableGame",
        "importPath": "gym.utils.play",
        "description": "gym.utils.play",
        "isExtraImport": true,
        "detail": "gym.utils.play",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "gym.utils.play",
        "description": "gym.utils.play",
        "isExtraImport": true,
        "detail": "gym.utils.play",
        "documentation": {}
    },
    {
        "label": "AsyncVectorEnv",
        "importPath": "gym.vector.async_vector_env",
        "description": "gym.vector.async_vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.async_vector_env",
        "documentation": {}
    },
    {
        "label": "AsyncVectorEnv",
        "importPath": "gym.vector.async_vector_env",
        "description": "gym.vector.async_vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.async_vector_env",
        "documentation": {}
    },
    {
        "label": "CustomSpace",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_custom_space_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_slow_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "custom_spaces",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "CustomSpace",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "assert_rng_equal",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "custom_spaces",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "CustomSpace",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "assert_rng_equal",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_custom_space_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "CustomSpace",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_env",
        "importPath": "tests.vector.utils",
        "description": "tests.vector.utils",
        "isExtraImport": true,
        "detail": "tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "concatenate",
        "importPath": "gym.vector.utils.numpy_utils",
        "description": "gym.vector.utils.numpy_utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils.numpy_utils",
        "documentation": {}
    },
    {
        "label": "create_empty_array",
        "importPath": "gym.vector.utils.numpy_utils",
        "description": "gym.vector.utils.numpy_utils",
        "isExtraImport": true,
        "detail": "gym.vector.utils.numpy_utils",
        "documentation": {}
    },
    {
        "label": "SynchronizedArray",
        "importPath": "multiprocessing.sharedctypes",
        "description": "multiprocessing.sharedctypes",
        "isExtraImport": true,
        "detail": "multiprocessing.sharedctypes",
        "documentation": {}
    },
    {
        "label": "create_shared_memory",
        "importPath": "gym.vector.utils.shared_memory",
        "description": "gym.vector.utils.shared_memory",
        "isExtraImport": true,
        "detail": "gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "read_from_shared_memory",
        "importPath": "gym.vector.utils.shared_memory",
        "description": "gym.vector.utils.shared_memory",
        "isExtraImport": true,
        "detail": "gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "write_to_shared_memory",
        "importPath": "gym.vector.utils.shared_memory",
        "description": "gym.vector.utils.shared_memory",
        "isExtraImport": true,
        "detail": "gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "assert_array_equal",
        "importPath": "numpy.testing",
        "description": "numpy.testing",
        "isExtraImport": true,
        "detail": "numpy.testing",
        "documentation": {}
    },
    {
        "label": "assert_almost_equal",
        "importPath": "numpy.testing",
        "description": "numpy.testing",
        "isExtraImport": true,
        "detail": "numpy.testing",
        "documentation": {}
    },
    {
        "label": "SyncVectorEnv",
        "importPath": "gym.vector.sync_vector_env",
        "description": "gym.vector.sync_vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.sync_vector_env",
        "documentation": {}
    },
    {
        "label": "SyncVectorEnv",
        "importPath": "gym.vector.sync_vector_env",
        "description": "gym.vector.sync_vector_env",
        "isExtraImport": true,
        "detail": "gym.vector.sync_vector_env",
        "documentation": {}
    },
    {
        "label": "VectorEnvWrapper",
        "importPath": "gym.vector",
        "description": "gym.vector",
        "isExtraImport": true,
        "detail": "gym.vector",
        "documentation": {}
    },
    {
        "label": "make",
        "importPath": "gym.vector",
        "description": "gym.vector",
        "isExtraImport": true,
        "detail": "gym.vector",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "FilterObservation",
        "importPath": "gym.wrappers.filter_observation",
        "description": "gym.wrappers.filter_observation",
        "isExtraImport": true,
        "detail": "gym.wrappers.filter_observation",
        "documentation": {}
    },
    {
        "label": "NormalizeObservation",
        "importPath": "gym.wrappers.normalize",
        "description": "gym.wrappers.normalize",
        "isExtraImport": true,
        "detail": "gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "NormalizeReward",
        "importPath": "gym.wrappers.normalize",
        "description": "gym.wrappers.normalize",
        "isExtraImport": true,
        "detail": "gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "STATE_KEY",
        "importPath": "gym.wrappers.pixel_observation",
        "description": "gym.wrappers.pixel_observation",
        "isExtraImport": true,
        "detail": "gym.wrappers.pixel_observation",
        "documentation": {}
    },
    {
        "label": "PixelObservationWrapper",
        "importPath": "gym.wrappers.pixel_observation",
        "description": "gym.wrappers.pixel_observation",
        "isExtraImport": true,
        "detail": "gym.wrappers.pixel_observation",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "VideoRecorder",
        "importPath": "gym.wrappers.monitoring.video_recorder",
        "description": "gym.wrappers.monitoring.video_recorder",
        "isExtraImport": true,
        "detail": "gym.wrappers.monitoring.video_recorder",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "importPath": "version",
        "description": "version",
        "isExtraImport": true,
        "detail": "version",
        "documentation": {}
    },
    {
        "label": "gnome_name",
        "importPath": "gnome_basic",
        "description": "gnome_basic",
        "isExtraImport": true,
        "detail": "gnome_basic",
        "documentation": {}
    },
    {
        "label": "demo_variable_imported_from_module",
        "importPath": "module_example",
        "description": "module_example",
        "isExtraImport": true,
        "detail": "module_example",
        "documentation": {}
    },
    {
        "label": "CorePlugin",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "peekOfCode": "class CorePlugin(BasePlugin):\n    name = \"coreplugin\"\n    version = \"0.3\"\n    def __init__(self):\n        BasePlugin.__init__(self)\n    def setup(self):\n        self.listener = CoreListener(self)\n        self.system.registerEvent(\"toolused\", self.listener)\nclass CoreListener(Listener):\n    def __init__(self, plugin):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "CoreListener",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "peekOfCode": "class CoreListener(Listener):\n    def __init__(self, plugin):\n        Listener.__init__(self, plugin)\n    def handler_pluginload(self, pluginname):\n        pass\n    def handler_toolused(self, position, gamemanager):\n        #print (\"Tool %s used on %s\" % (toolname, str(position)))\n        player = gamemanager.getplayer()\n        farm = gamemanager.getfarm()\n        toolname = player.selectedtool",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "REMOVEWILTEDCOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "peekOfCode": "REMOVEWILTEDCOST = rules[\"REMOVEWILTEDCOST\"]\nREMOVEANTHILLCOST = rules[\"REMOVEANTHILLCOST\"]\nREMOVESTONECOST = rules[\"REMOVESTONECOST\"]\nclass CorePlugin(BasePlugin):\n    name = \"coreplugin\"\n    version = \"0.3\"\n    def __init__(self):\n        BasePlugin.__init__(self)\n    def setup(self):\n        self.listener = CoreListener(self)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "REMOVEANTHILLCOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "peekOfCode": "REMOVEANTHILLCOST = rules[\"REMOVEANTHILLCOST\"]\nREMOVESTONECOST = rules[\"REMOVESTONECOST\"]\nclass CorePlugin(BasePlugin):\n    name = \"coreplugin\"\n    version = \"0.3\"\n    def __init__(self):\n        BasePlugin.__init__(self)\n    def setup(self):\n        self.listener = CoreListener(self)\n        self.system.registerEvent(\"toolused\", self.listener)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "REMOVESTONECOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "peekOfCode": "REMOVESTONECOST = rules[\"REMOVESTONECOST\"]\nclass CorePlugin(BasePlugin):\n    name = \"coreplugin\"\n    version = \"0.3\"\n    def __init__(self):\n        BasePlugin.__init__(self)\n    def setup(self):\n        self.listener = CoreListener(self)\n        self.system.registerEvent(\"toolused\", self.listener)\nclass CoreListener(Listener):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.coreplugin",
        "documentation": {}
    },
    {
        "label": "DictMapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.dictmapper",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.dictmapper",
        "peekOfCode": "class DictMapper():\n    def __init__(self, dicttomap={}):\n        self._dict = dicttomap\n    def __str__(self):\n        return repr(self._dict)\n    def __iter__(self):\n        return iter(self._dict.values())\n    def __setitem__(self, name, value):\n        self._dict[name] = value\n    def keys(self):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.dictmapper",
        "documentation": {}
    },
    {
        "label": "ExpBar",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.expbar",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.expbar",
        "peekOfCode": "class ExpBar(Label):\n    def __init__(self, player):\n        self.player = player\n        self.oldexp = -1.0\n        Label.__init__(self, \"\", (9, 58))\n    def update_text(self):\n        # get data\n        exp = self.player.exp\n        nextlvlexp = self.player.nextlvlexp\n        level = self.player.level",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.expbar",
        "documentation": {}
    },
    {
        "label": "FarmTile",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "peekOfCode": "class FarmTile:\n    \"\"\"Farm tile represent one tile on each farm\"\"\"\n    def __init__(self, obj=None):\n        self.water = 0.0\n        self.farmobject = obj\n        self.posx = -1\n        self.posy = -1\n    def __getitem__(self, name):\n        if name == \"water\":\n            return self.get_water()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "documentation": {}
    },
    {
        "label": "FarmField",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "peekOfCode": "class FarmField:\n    \"\"\"Represent Farm 12x12 in size each\"\"\"\n    def __init__(self, gm):\n        \"\"\" Init FarmField\"\"\"\n        self.gamemanager = gm\n        self.farmtiles = {}\n        self.raining = False\n        self.raintime = time.time()\n        self.last_checksum = \"\"\n        self.seconds_to_update = 0",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "documentation": {}
    },
    {
        "label": "FarmObject",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "peekOfCode": "class FarmObject:\n    \"\"\"Represent Each object possible to place on Farm\"\"\"\n    def __init__(self):\n        self.name = \"\"\n        self.description = \"\"\n        self.id = 0\n        self.price = 0\n        self.type = \"\"\n    def apply_dict(self, dictionary):\n        \"\"\"apply dictionary to object\"\"\"",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "documentation": {}
    },
    {
        "label": "Seed",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "peekOfCode": "class Seed(FarmObject):\n    \"\"\"Represent seed farmobject\"\"\"\n    def __init__(self):\n        \"\"\"Init new seed\"\"\"\n        FarmObject.__init__(self)\n        self.type = \"seed\"\n        self.growtime = 60  # grow time in seconds\n        self.growstarttime = 0  # when grow was been started\n        self.growquantity = 2  # how many new seeds you got when seed fully grow\n        self.growendtime = 0",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "documentation": {}
    },
    {
        "label": "objects",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "peekOfCode": "objects = DictMapper()\nobjects.load(os.path.join(\"data\", \"objects.json\"))",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.farm",
        "documentation": {}
    },
    {
        "label": "GameManager",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamemanager",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamemanager",
        "peekOfCode": "class GameManager:\n    def __init__(self):\n        self.farms = []\n        self.gameseed = int(time.time())\n        self.gametime = int(time.time())\n        self.current_farm = 0\n        self.player = Player()\n    def getfarm(self, farmid=None):\n        if farmid is None:\n            farmid = self.current_farm",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamemanager",
        "documentation": {}
    },
    {
        "label": "GameWindow",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "class GameWindow(Window):\n    def __init__(self):\n        Window.__init__(self, (800, 600), (0, 0))\n        self.lazyscreen = None\n        # Create gamemanager\n        self.gamemanager = GameManager()\n        # timers\n        self.eventstimer = Timer()\n        self.updatetimer = Timer()\n        self.images = ImageLoader(imagesdata)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "REMOVEWILTEDCOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "REMOVEWILTEDCOST = farmlib.rules[\"REMOVEWILTEDCOST\"]\nREMOVEANTHILLCOST = farmlib.rules[\"REMOVEANTHILLCOST\"]\nREMOVESTONECOST = farmlib.rules[\"REMOVESTONECOST\"]\nTOOLS = [\"harvest\", \"plant\", \"watering\", \"shovel\", \"pickaxe\", \"axe\"]\n# Images data\nimagesdata = farmlib.images[\"imagesdata\"]\n# merge objects images data (objects image have objects/objects+id.png)\nfor gobject in objects:\n    name = \"object\" + str(gobject['id']) + \".png\"\n    objectsimagepath = os.path.join(\"images\", os.path.join(\"objects\", name))",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "REMOVEANTHILLCOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "REMOVEANTHILLCOST = farmlib.rules[\"REMOVEANTHILLCOST\"]\nREMOVESTONECOST = farmlib.rules[\"REMOVESTONECOST\"]\nTOOLS = [\"harvest\", \"plant\", \"watering\", \"shovel\", \"pickaxe\", \"axe\"]\n# Images data\nimagesdata = farmlib.images[\"imagesdata\"]\n# merge objects images data (objects image have objects/objects+id.png)\nfor gobject in objects:\n    name = \"object\" + str(gobject['id']) + \".png\"\n    objectsimagepath = os.path.join(\"images\", os.path.join(\"objects\", name))\n    imagesdata[\"object\" + str(gobject['id'])] = objectsimagepath",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "REMOVESTONECOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "REMOVESTONECOST = farmlib.rules[\"REMOVESTONECOST\"]\nTOOLS = [\"harvest\", \"plant\", \"watering\", \"shovel\", \"pickaxe\", \"axe\"]\n# Images data\nimagesdata = farmlib.images[\"imagesdata\"]\n# merge objects images data (objects image have objects/objects+id.png)\nfor gobject in objects:\n    name = \"object\" + str(gobject['id']) + \".png\"\n    objectsimagepath = os.path.join(\"images\", os.path.join(\"objects\", name))\n    imagesdata[\"object\" + str(gobject['id'])] = objectsimagepath\nclass GameWindow(Window):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "TOOLS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "TOOLS = [\"harvest\", \"plant\", \"watering\", \"shovel\", \"pickaxe\", \"axe\"]\n# Images data\nimagesdata = farmlib.images[\"imagesdata\"]\n# merge objects images data (objects image have objects/objects+id.png)\nfor gobject in objects:\n    name = \"object\" + str(gobject['id']) + \".png\"\n    objectsimagepath = os.path.join(\"images\", os.path.join(\"objects\", name))\n    imagesdata[\"object\" + str(gobject['id'])] = objectsimagepath\nclass GameWindow(Window):\n    def __init__(self):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "imagesdata",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "peekOfCode": "imagesdata = farmlib.images[\"imagesdata\"]\n# merge objects images data (objects image have objects/objects+id.png)\nfor gobject in objects:\n    name = \"object\" + str(gobject['id']) + \".png\"\n    objectsimagepath = os.path.join(\"images\", os.path.join(\"objects\", name))\n    imagesdata[\"object\" + str(gobject['id'])] = objectsimagepath\nclass GameWindow(Window):\n    def __init__(self):\n        Window.__init__(self, (800, 600), (0, 0))\n        self.lazyscreen = None",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.gamewindow",
        "documentation": {}
    },
    {
        "label": "HelpWindow",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.helpwindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.helpwindow",
        "peekOfCode": "class HelpWindow(Window):\n    def __init__(self, size):\n        Window.__init__(self, size, (150, 40))\n        # set window alpha\n        self.alphavalue = 250 * 0.95\n        # Create gui\n        self.create_gui()\n        # hide market at load\n        self.hide()\n    def create_gui(self):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.helpwindow",
        "documentation": {}
    },
    {
        "label": "ImageLoader",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.imageloader",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.imageloader",
        "peekOfCode": "class ImageLoader:\n    def __init__(self, imagesdict):\n        self.config = imagesdict\n        self.loaded = {}\n        self.empty = pygame.Surface((64, 32))\n    def __getitem__(self, name):\n        return self.loadimage(name)\n    def loadimages(self):\n        \"\"\"Load all images\"\"\"\n        for item in self.config.keys():",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.imageloader",
        "documentation": {}
    },
    {
        "label": "InventoryWindow",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.inventorywindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.inventorywindow",
        "peekOfCode": "class InventoryWindow(Container):\n    def __init__(self, imgloader, player):\n        Container.__init__(self, (400, 500), (200, 50))\n        self.inventoryoffset = (0, 10)\n        self.inventorysize = (4, 5)\n        self.images = imgloader\n        self.player = player\n        self.notifyfont = pygame.font.Font(\"dejavusansmono.ttf\", 12)\n        # tooltip\n        self.tooltip = [None, None]",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.inventorywindow",
        "documentation": {}
    },
    {
        "label": "MarketWindow",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "peekOfCode": "class MarketWindow(Container):\n    def __init__(self, size, imgloader, player, gamemanager):\n        self.gamemanager = gamemanager\n        self.player = player\n        self.imgloader = imgloader\n        Container.__init__(self, size, (200, 50))\n        # set window alpha\n        self.alphavalue = 250 * 0.95\n        # items offset for gui buttons\n        self.itemsoffset = [32, 20]",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "documentation": {}
    },
    {
        "label": "WATERREFILLCOST",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "peekOfCode": "WATERREFILLCOST = farmlib.rules[\"WATERREFILLCOST\"]\nOBJECTSNOTINMARKET = farmlib.rules[\"OBJECTSNOTINMARKET\"]\nclass MarketWindow(Container):\n    def __init__(self, size, imgloader, player, gamemanager):\n        self.gamemanager = gamemanager\n        self.player = player\n        self.imgloader = imgloader\n        Container.__init__(self, size, (200, 50))\n        # set window alpha\n        self.alphavalue = 250 * 0.95",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "documentation": {}
    },
    {
        "label": "OBJECTSNOTINMARKET",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "peekOfCode": "OBJECTSNOTINMARKET = farmlib.rules[\"OBJECTSNOTINMARKET\"]\nclass MarketWindow(Container):\n    def __init__(self, size, imgloader, player, gamemanager):\n        self.gamemanager = gamemanager\n        self.player = player\n        self.imgloader = imgloader\n        Container.__init__(self, size, (200, 50))\n        # set window alpha\n        self.alphavalue = 250 * 0.95\n        # items offset for gui buttons",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.marketwindow",
        "documentation": {}
    },
    {
        "label": "MenuWindow",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.menuwindow",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.menuwindow",
        "peekOfCode": "class MenuWindow(Container):\n    def __init__(self):\n        self.parent = None\n        Container.__init__(self, (800, 600), (0, 0))\n        self.running = True\n        self.menupos = 0\n        self.maxmenupos = 1\n        # background\n        imgpath = os.path.join(\"images\", \"gui\", \"mainmenubg.png\")\n        bgimage = pygame.image.load(imgpath).convert_alpha()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.menuwindow",
        "documentation": {}
    },
    {
        "label": "Player",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.player",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.player",
        "peekOfCode": "class Player:\n    def __init__(self):\n        self.inventory = [3]\n        self.itemscounter = {'3': 2}\n        self.money = 0\n        self.watercanuses = 100\n        # Skill\n        self.exp = 0.0\n        self.nextlvlexp = 100.0\n        self.level = 1",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.player",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "class Event:\n    \"\"\"\n    Base event\n    Event name will be lowercase\n    \"\"\"\n    def __init__(self, name, **args):\n        self.name = name.lower()\n        self.args = args\n        self.priority = PRIORITY_NORMAL\n    def __str__(self):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "Listener",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "class Listener:\n    \"\"\"\n    Base listener\n    \"\"\"\n    def __init__(self, plugin):\n        self.plugin = plugin\n        self.eventdef = {}  # dict for supported events for listener\n    def isEventSupported(self, eventname):\n        \"\"\"\n        Return True when eventname is supported by this listener",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "BasePlugin",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "class BasePlugin:\n    \"\"\"\n    Base Plugin\n    \"\"\"\n    name = \"nonameplugin\"\n    version = \"0.0\"\n    def __init__(self):\n        \"\"\"Init base plugin\"\"\"\n        self.system = None  # Plugin system object when installed\n    def registerGlobalHook(self, hookname, function):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "PluginSystem",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "class PluginSystem:\n    \"\"\"\n    Plugin system. Only one instance for application.\n    \"\"\"\n    def __init__(self):\n        self.eventqueue = []  # Event queue\n        self._plugins = []  # Plugins list\n        self._listeners = []  # Listeners tuple\n        self.globalhooks = {}  # Dict for global hooks\n        self.debug = True",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "PRIORITY_LOW",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "PRIORITY_LOW = -10\nPRIORITY_NORMAL = 0\nPRIORITY_HIGH = 10\n#################\n# EVENT\n#################\nclass Event:\n    \"\"\"\n    Base event\n    Event name will be lowercase",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "PRIORITY_NORMAL",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "PRIORITY_NORMAL = 0\nPRIORITY_HIGH = 10\n#################\n# EVENT\n#################\nclass Event:\n    \"\"\"\n    Base event\n    Event name will be lowercase\n    \"\"\"",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "PRIORITY_HIGH",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "PRIORITY_HIGH = 10\n#################\n# EVENT\n#################\nclass Event:\n    \"\"\"\n    Base event\n    Event name will be lowercase\n    \"\"\"\n    def __init__(self, name, **args):",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "basePluginSystem",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "peekOfCode": "basePluginSystem = PluginSystem()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pluginsystem",
        "documentation": {}
    },
    {
        "label": "lerp",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "peekOfCode": "def lerp(t, a, b):\n    return a + t * (b - a)\ndef fade(t):\n    return t * t * t * (t * (t * 6 - 15) + 10)\ndef grad(hash, x, y, z):\n    h = hash & 15\n    if h < 8:\n        u = x\n    else:\n        u = y",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "documentation": {}
    },
    {
        "label": "fade",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "peekOfCode": "def fade(t):\n    return t * t * t * (t * (t * 6 - 15) + 10)\ndef grad(hash, x, y, z):\n    h = hash & 15\n    if h < 8:\n        u = x\n    else:\n        u = y\n    if h < 4:\n        v = y",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "documentation": {}
    },
    {
        "label": "grad",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "peekOfCode": "def grad(hash, x, y, z):\n    h = hash & 15\n    if h < 8:\n        u = x\n    else:\n        u = y\n    if h < 4:\n        v = y\n    elif h == 12 or h == 14:\n        v = x",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "documentation": {}
    },
    {
        "label": "pnoise",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "peekOfCode": "def pnoise(x, y, z):\n    global p\n    X = int(math.floor(x)) & 255\n    Y = int(math.floor(y)) & 255\n    Z = int(math.floor(z)) & 255\n    x -= math.floor(x)\n    y -= math.floor(y)\n    z -= math.floor(z)\n    u = fade(x)\n    v = fade(y)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "peekOfCode": "p = (\n    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103,\n    30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197,\n    62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20,\n    125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231,\n    83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102,\n    143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200,\n    196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n    250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16,\n    58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.pnoise",
        "documentation": {}
    },
    {
        "label": "draw_tools",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def draw_tools(surface, currenttool, currentseed, imgloader,\n               drawnearcursor=True):\n    # Draw selection on selected tool\n    if currenttool == 'harvest':\n        pygame.draw.rect(surface, (255, 255, 255), (10, 10, 48, 48), 1)\n    if currenttool == 'plant':\n        pygame.draw.rect(surface, (255, 255, 255), (60, 10, 48, 48), 1)\n    if currenttool == 'watering':\n        pygame.draw.rect(surface, (255, 255, 255), (110, 10, 48, 48), 1)\n    if currenttool == 'shovel':",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "draw_seed",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def draw_seed(surface, seedid, position, imgloader):\n    img = imgloader.loadimage('object' + str(seedid))\n    surface.blit(img, position)\ndef draw_selected_seed(surface, selectedseed, imgloader):\n    if selectedseed == None:\n        return\n    # draw selected seed\n    img = imgloader.loadimage('dryground')\n    surface.blit(img, (65, 90))\n    draw_seed(surface, selectedseed, (65, 90), imgloader)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "draw_selected_seed",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def draw_selected_seed(surface, selectedseed, imgloader):\n    if selectedseed == None:\n        return\n    # draw selected seed\n    img = imgloader.loadimage('dryground')\n    surface.blit(img, (65, 90))\n    draw_seed(surface, selectedseed, (65, 90), imgloader)\ndef render_seed_notify(surface, font, posx, posy, farmobject, farmtile,\n                       imgloader):\n    \"\"\"Render notification about farm object\"\"\"",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_seed_notify",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def render_seed_notify(surface, font, posx, posy, farmobject, farmtile,\n                       imgloader):\n    \"\"\"Render notification about farm object\"\"\"\n    if farmobject is None:\n        return\n    sizex = 250\n    sizey = 150\n    posy += 5\n    img = pygame.Surface((sizex, sizey))\n    img.fill((48, 80, 80))",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_rain",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def render_rain(surface):\n    for x in range(30):\n        xx = random.randint(0, surface.get_size()[0])\n        yy = random.randint(0, 200)\n        offset = random.randint(-15, -8)\n        pygame.draw.line(surface, (0, 0, 200), (xx, yy),\n                         (xx + offset, yy + 15))\ndef render_one_field(position, screen, imgloader, farmfield, farmoffset):\n    \"\"\"Render one field from farm\"\"\"\n    mainimg = screen",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_one_field",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def render_one_field(position, screen, imgloader, farmfield, farmoffset):\n    \"\"\"Render one field from farm\"\"\"\n    mainimg = screen\n    x, y = position\n    farmtile = farmfield.get_farmtile(x, y)\n    posx = (x - y) * 32 + farmoffset[0] + 150\n    posy = (x + y) * 16 + farmoffset[1]\n    rect = (posx, posy, 64, 32)\n    # draw ground\n    if farmtile['water'] >= 30:",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "render_field",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "peekOfCode": "def render_field(screen, imgloader, farmfield, farmoffset):\n    img = pygame.surface.Surface((800, 600))\n    img.set_colorkey((0, 0, 0))\n    for y in range(12):\n        for x in range(12):\n            render_one_field((x, y), img,\n                             imgloader, farmfield, farmoffset)\n    return img",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.renderfunctions",
        "documentation": {}
    },
    {
        "label": "Timer",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.timer",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.timer",
        "peekOfCode": "class Timer:\n    def __init__(self):\n        self.lasttick = 0.0\n        self.tickcount = -1\n        self.lastticktime = 0.0\n    def tick(self, destfps=0):\n        \"\"\"Tick a timer. If the destfps was given then application will not run\n        faster then destfps frames per second\"\"\"\n        self.lastticktime = time.time() - self.lasttick\n        self.lasttick = time.time()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.timer",
        "documentation": {}
    },
    {
        "label": "Tooltip",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.farmlib.tooltip",
        "description": "repos_that_could_be_useful.PythonFarmGame.farmlib.tooltip",
        "peekOfCode": "class Tooltip(Window):\n    def __init__(self, position, data):\n        \"\"\"\n            create tooltip window. data must be list of pairs [\"label\", \"value\"]\n        \"\"\"\n        Window.__init__(self, (0, 0), position)\n        self.data = data\n        self.alphavalue = 200\n        #\n        self.crete_widgets()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.farmlib.tooltip",
        "documentation": {}
    },
    {
        "label": "Button",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "peekOfCode": "class Button(Widget):\n    def __init__(self, label, position, bgimage = None, labelsize = 12,\n                 color = (255, 255, 0)):\n        self.bgimage = bgimage\n        self.label = label\n        self.color = color\n        self.position = position\n        self.labelsize = labelsize\n        self.labelfont = pygame.font.Font(\"dejavusansmono.ttf\", self.labelsize)\n        self.buttonbgorg = pygame.image.load(buttonbgpath).convert_alpha()",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "documentation": {}
    },
    {
        "label": "buttonbgpath",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "peekOfCode": "buttonbgpath = os.path.join(\"images\", \"gui\", \"buttonbg.png\")\nclass Button(Widget):\n    def __init__(self, label, position, bgimage = None, labelsize = 12,\n                 color = (255, 255, 0)):\n        self.bgimage = bgimage\n        self.label = label\n        self.color = color\n        self.position = position\n        self.labelsize = labelsize\n        self.labelfont = pygame.font.Font(\"dejavusansmono.ttf\", self.labelsize)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.button",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.container",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.container",
        "peekOfCode": "class Container(Widget):\n    '''\n    Container for gui\n    '''\n    def __init__(self, (width, height), position):\n        Widget.__init__(self, position, (width, height))\n        self.widgets = []\n        self.visible = True\n        #last active widget\n        self._lastactivewidget = None",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.container",
        "documentation": {}
    },
    {
        "label": "Image",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.image",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.image",
        "peekOfCode": "class Image(Widget):\n    def __init__(self, image, position):\n        self.image = image\n        self.position = position\n        #set width and height\n        if self.image:\n            self.width = self.image.get_size()[0]\n            self.height = self.image.get_size()[1]\n        else:\n            self._setsize((0, 0))",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.image",
        "documentation": {}
    },
    {
        "label": "Label",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.label",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.label",
        "peekOfCode": "class Label(Widget):\n    def __init__(self, text, position, size = 12,\n            color = (255, 255, 255), align = \"left\"):\n        self.text = text\n        self.labelfont = pygame.font.Font(\"dejavusansmono.ttf\", size)\n        self.image = None\n        self.color = color\n        self.position = position\n        self.orginal_position = position\n        self.align = align",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.label",
        "documentation": {}
    },
    {
        "label": "Widget",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.widget",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.widget",
        "peekOfCode": "class Widget:\n    '''\n    Widget for gui\n    '''\n    def __init__(self, position, (width, height)):\n        #parent widget should inherit from Container\n        self.parent = None\n        self.position = position\n        self.width = width\n        self.height = height",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.widget",
        "documentation": {}
    },
    {
        "label": "Window",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pygameui.window",
        "description": "repos_that_could_be_useful.PythonFarmGame.pygameui.window",
        "peekOfCode": "class Window(Container):\n    '''\n    Window for gui\n    '''\n    def __init__(self, (width, height), position):\n        Container.__init__(self, (width, height), position)\n        self.alphavalue = 196\n        #border\n        self.showborder = True\n        self.bordercolor = (128, 128, 0)",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pygameui.window",
        "documentation": {}
    },
    {
        "label": "FarmGamePygame",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.PythonFarmGame.pyFarmGame",
        "description": "repos_that_could_be_useful.PythonFarmGame.pyFarmGame",
        "peekOfCode": "class FarmGamePygame:\n    def __init__(self):\n        \"\"\"Init game\"\"\"\n        self.screen = pygame.display.set_mode((800, 600), pygame.DOUBLEBUF)\n        pygame.display.set_caption(\"PyFarmGame \" + \"v. \" + __VERSION__)\n        #timer\n        self.timer = pygame.time.Clock()\n        self.activescr = None\n        self.ingame = False\n        self.inmenu = True",
        "detail": "repos_that_could_be_useful.PythonFarmGame.pyFarmGame",
        "documentation": {}
    },
    {
        "label": "ContactDetector",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "class ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (\n            self.env.hull == contact.fixtureA.body\n            or self.env.hull == contact.fixtureB.body\n        ):\n            self.env.game_over = True",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "BipedalWalker",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "class BipedalWalker(gym.Env, EzPickle):\n    \"\"\"\n    ### Description\n    This is a simple 4-joint walker robot environment.\n    There are two versions:\n    - Normal, with slightly uneven terrain.\n    - Hardcore, with ladders, stumps, pitfalls.\n    To solve the normal version, you need to get 300 points in 1600 time steps.\n    To solve the hardcore version, you need 300 points in 2000 time steps.\n    A heuristic is provided for testing. It's also useful to get demonstrations",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "BipedalWalkerHardcore",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "class BipedalWalkerHardcore:\n    def __init__(self):\n        raise error.Error(\n            \"Error initializing BipedalWalkerHardcore Environment.\\n\"\n            \"Currently, we do not support initializing this mode of environment by calling the class directly.\\n\"\n            \"To use this environment, instead create it by specifying the hardcore keyword in gym.make, i.e.\\n\"\n            'gym.make(\"BipedalWalker-v3\", hardcore=True)'\n        )\nif __name__ == \"__main__\":\n    # Heurisic: suboptimal, have no notion of balance.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "__credits__ = [\"Andrea PIERR\"]\nimport math\nfrom typing import Optional\nimport numpy as np\nimport gym\nfrom gym import error, spaces\nfrom gym.error import DependencyNotInstalled\nfrom gym.utils import EzPickle\ntry:\n    import Box2D",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "FPS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "FPS = 50\nSCALE = 30.0  # affects how fast-paced the game is, forces should be adjusted as well\nMOTORS_TORQUE = 80\nSPEED_HIP = 4\nSPEED_KNEE = 6\nLIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "SCALE = 30.0  # affects how fast-paced the game is, forces should be adjusted as well\nMOTORS_TORQUE = 80\nSPEED_HIP = 4\nSPEED_KNEE = 6\nLIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "MOTORS_TORQUE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "MOTORS_TORQUE = 80\nSPEED_HIP = 4\nSPEED_KNEE = 6\nLIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "SPEED_HIP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "SPEED_HIP = 4\nSPEED_KNEE = 6\nLIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "SPEED_KNEE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "SPEED_KNEE = 6\nLIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "LIDAR_RANGE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "LIDAR_RANGE = 160 / SCALE\nINITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "INITIAL_RANDOM",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "INITIAL_RANDOM = 5\nHULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "HULL_POLY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "HULL_POLY = [(-30, +9), (+6, +9), (+34, +1), (+34, -8), (-30, -8)]\nLEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "LEG_DOWN",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "LEG_DOWN = -8 / SCALE\nLEG_W, LEG_H = 8 / SCALE, 34 / SCALE\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "VIEWPORT_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "VIEWPORT_W = 600\nVIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "VIEWPORT_H",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "VIEWPORT_H = 400\nTERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "TERRAIN_STEP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "TERRAIN_STEP = 14 / SCALE\nTERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "TERRAIN_LENGTH",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "TERRAIN_LENGTH = 200  # in steps\nTERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "TERRAIN_HEIGHT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "TERRAIN_HEIGHT = VIEWPORT_H / SCALE / 4\nTERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,\n    maskBits=0x001,  # collide only with ground",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "TERRAIN_GRASS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "TERRAIN_GRASS = 10  # low long are grass spots, in steps\nTERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,\n    maskBits=0x001,  # collide only with ground\n    restitution=0.0,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "TERRAIN_STARTPAD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "TERRAIN_STARTPAD = 20  # in steps\nFRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,\n    maskBits=0x001,  # collide only with ground\n    restitution=0.0,\n)  # 0.99 bouncy",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "FRICTION",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "FRICTION = 2.5\nHULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,\n    maskBits=0x001,  # collide only with ground\n    restitution=0.0,\n)  # 0.99 bouncy\nLEG_FD = fixtureDef(",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "HULL_FD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "HULL_FD = fixtureDef(\n    shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in HULL_POLY]),\n    density=5.0,\n    friction=0.1,\n    categoryBits=0x0020,\n    maskBits=0x001,  # collide only with ground\n    restitution=0.0,\n)  # 0.99 bouncy\nLEG_FD = fixtureDef(\n    shape=polygonShape(box=(LEG_W / 2, LEG_H / 2)),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "LEG_FD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "LEG_FD = fixtureDef(\n    shape=polygonShape(box=(LEG_W / 2, LEG_H / 2)),\n    density=1.0,\n    restitution=0.0,\n    categoryBits=0x0020,\n    maskBits=0x001,\n)\nLOWER_FD = fixtureDef(\n    shape=polygonShape(box=(0.8 * LEG_W / 2, LEG_H / 2)),\n    density=1.0,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "LOWER_FD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "peekOfCode": "LOWER_FD = fixtureDef(\n    shape=polygonShape(box=(0.8 * LEG_W / 2, LEG_H / 2)),\n    density=1.0,\n    restitution=0.0,\n    categoryBits=0x0020,\n    maskBits=0x001,\n)\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.bipedal_walker",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "class Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),\n            angle=init_angle,\n            fixtures=[\n                fixtureDef(\n                    shape=polygonShape(\n                        vertices=[(x * SIZE, y * SIZE) for x, y in HULL_POLY1]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "SIZE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "SIZE = 0.02\nENGINE_POWER = 100000000 * SIZE * SIZE\nWHEEL_MOMENT_OF_INERTIA = 4000 * SIZE * SIZE\nFRICTION_LIMIT = (\n    1000000 * SIZE * SIZE\n)  # friction ~= mass ~= size^2 (calculated implicitly using density)\nWHEEL_R = 27\nWHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "ENGINE_POWER",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "ENGINE_POWER = 100000000 * SIZE * SIZE\nWHEEL_MOMENT_OF_INERTIA = 4000 * SIZE * SIZE\nFRICTION_LIMIT = (\n    1000000 * SIZE * SIZE\n)  # friction ~= mass ~= size^2 (calculated implicitly using density)\nWHEEL_R = 27\nWHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEEL_MOMENT_OF_INERTIA",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEEL_MOMENT_OF_INERTIA = 4000 * SIZE * SIZE\nFRICTION_LIMIT = (\n    1000000 * SIZE * SIZE\n)  # friction ~= mass ~= size^2 (calculated implicitly using density)\nWHEEL_R = 27\nWHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "FRICTION_LIMIT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "FRICTION_LIMIT = (\n    1000000 * SIZE * SIZE\n)  # friction ~= mass ~= size^2 (calculated implicitly using density)\nWHEEL_R = 27\nWHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEEL_R",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEEL_R = 27\nWHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEEL_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEEL_W = 14\nWHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),\n    (-20, -90),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEELPOS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEELPOS = [(-55, +80), (+55, +80), (-55, -82), (+55, -82)]\nHULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),\n    (-20, -90),\n    (-50, -40),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "HULL_POLY1",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "HULL_POLY1 = [(-60, +130), (+60, +130), (+60, +110), (-60, +110)]\nHULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),\n    (-20, -90),\n    (-50, -40),\n    (-50, -10),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "HULL_POLY2",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "HULL_POLY2 = [(-15, +120), (+15, +120), (+20, +20), (-20, 20)]\nHULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),\n    (-20, -90),\n    (-50, -40),\n    (-50, -10),\n    (-25, +20),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "HULL_POLY3",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "HULL_POLY3 = [\n    (+25, +20),\n    (+50, -10),\n    (+50, -40),\n    (+20, -90),\n    (-20, -90),\n    (-50, -40),\n    (-50, -10),\n    (-25, +20),\n]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "HULL_POLY4",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "HULL_POLY4 = [(-50, -120), (+50, -120), (+50, -90), (-50, -90)]\nWHEEL_COLOR = (0, 0, 0)\nWHEEL_WHITE = (77, 77, 77)\nMUD_COLOR = (102, 102, 0)\nSCALE = 6.0  # Track scale\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEEL_COLOR",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEEL_COLOR = (0, 0, 0)\nWHEEL_WHITE = (77, 77, 77)\nMUD_COLOR = (102, 102, 0)\nSCALE = 6.0  # Track scale\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "WHEEL_WHITE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "WHEEL_WHITE = (77, 77, 77)\nMUD_COLOR = (102, 102, 0)\nSCALE = 6.0  # Track scale\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),\n            angle=init_angle,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "MUD_COLOR",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "MUD_COLOR = (102, 102, 0)\nSCALE = 6.0  # Track scale\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),\n            angle=init_angle,\n            fixtures=[",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "SCALE = 6.0  # Track scale\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),\n            angle=init_angle,\n            fixtures=[\n                fixtureDef(",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "PLAYFIELD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "peekOfCode": "PLAYFIELD = 2000 / SCALE  # Game over boundary\nclass Car:\n    def __init__(self, world, init_angle, init_x, init_y):\n        self.world = world\n        self.hull = self.world.CreateDynamicBody(\n            position=(init_x, init_y),\n            angle=init_angle,\n            fixtures=[\n                fixtureDef(\n                    shape=polygonShape(",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_dynamics",
        "documentation": {}
    },
    {
        "label": "FrictionDetector",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "class FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent\n    def BeginContact(self, contact):\n        self._contact(contact, True)\n    def EndContact(self, contact):\n        self._contact(contact, False)\n    def _contact(self, contact, begin):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "CarRacing",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "class CarRacing(gym.Env, EzPickle):\n    \"\"\"\n    ### Description\n    The easiest control task to learn from pixels - a top-down\n    racing environment. The generated track is random every episode.\n    Some indicators are shown at the bottom of the window along with the\n    state RGB buffer. From left to right: true speed, four ABS sensors,\n    steering wheel position, and gyroscope.\n    To play yourself (it's rather fast for humans), type:\n    ```",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "__credits__ = [\"Andrea PIERR\"]\nimport math\nfrom typing import Optional, Union\nimport numpy as np\nimport gym\nfrom gym import spaces\nfrom gym.envs.box2d.car_dynamics import Car\nfrom gym.error import DependencyNotInstalled\nfrom gym.utils import EzPickle\ntry:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "STATE_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "STATE_W = 96  # less than Atari 160x192\nSTATE_H = 96\nVIDEO_W = 600\nVIDEO_H = 400\nWINDOW_W = 1000\nWINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "STATE_H",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "STATE_H = 96\nVIDEO_W = 600\nVIDEO_H = 400\nWINDOW_W = 1000\nWINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "VIDEO_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "VIDEO_W = 600\nVIDEO_H = 400\nWINDOW_W = 1000\nWINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "VIDEO_H",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "VIDEO_H = 400\nWINDOW_W = 1000\nWINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "WINDOW_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "WINDOW_W = 1000\nWINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "WINDOW_H",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "WINDOW_H = 800\nSCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "SCALE = 6.0  # Track scale\nTRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "TRACK_RAD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "TRACK_RAD = 900 / SCALE  # Track is heavily morphed circle with this radius\nPLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "PLAYFIELD",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "PLAYFIELD = 2000 / SCALE  # Game over boundary\nFPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "FPS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "FPS = 50  # Frames per second\nZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "ZOOM",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "ZOOM = 2.7  # Camera zoom\nZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "ZOOM_FOLLOW",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "ZOOM_FOLLOW = True  # Set to False for fixed view (don't use zoom)\nTRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "TRACK_DETAIL_STEP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "TRACK_DETAIL_STEP = 21 / SCALE\nTRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "TRACK_TURN_RATE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "TRACK_TURN_RATE = 0.31\nTRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent\n    def BeginContact(self, contact):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "TRACK_WIDTH",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "TRACK_WIDTH = 40 / SCALE\nBORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent\n    def BeginContact(self, contact):\n        self._contact(contact, True)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "BORDER",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "BORDER = 8 / SCALE\nBORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent\n    def BeginContact(self, contact):\n        self._contact(contact, True)\n    def EndContact(self, contact):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "BORDER_MIN_COUNT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "peekOfCode": "BORDER_MIN_COUNT = 4\nclass FrictionDetector(contactListener):\n    def __init__(self, env, lap_complete_percent):\n        contactListener.__init__(self)\n        self.env = env\n        self.lap_complete_percent = lap_complete_percent\n    def BeginContact(self, contact):\n        self._contact(contact, True)\n    def EndContact(self, contact):\n        self._contact(contact, False)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.car_racing",
        "documentation": {}
    },
    {
        "label": "ContactDetector",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "class ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (\n            self.env.lander == contact.fixtureA.body\n            or self.env.lander == contact.fixtureB.body\n        ):\n            self.env.game_over = True",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LunarLander",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "class LunarLander(gym.Env, EzPickle):\n    \"\"\"\n    ### Description\n    This environment is a classic rocket trajectory optimization problem.\n    According to Pontryagin's maximum principle, it is optimal to fire the\n    engine at full throttle or turn it off. This is the reason why this\n    environment has discrete actions: engine on or off.\n    There are two environment versions: discrete or continuous.\n    The landing pad is always at coordinates (0,0). The coordinates are the\n    first two numbers in the state vector.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LunarLanderContinuous",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "class LunarLanderContinuous:\n    def __init__(self):\n        raise error.Error(\n            \"Error initializing LunarLanderContinuous Environment.\\n\"\n            \"Currently, we do not support initializing this mode of environment by calling the class directly.\\n\"\n            \"To use this environment, instead create it by specifying the continuous keyword in gym.make, i.e.\\n\"\n            'gym.make(\"LunarLander-v2\", continuous=True)'\n        )\nif __name__ == \"__main__\":\n    demo_heuristic_lander(LunarLander(), render=True)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "heuristic",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "def heuristic(env, s):\n    \"\"\"\n    The heuristic for\n    1. Testing\n    2. Demonstration rollout.\n    Args:\n        env: The environment\n        s (list): The state. Attributes:\n                  s[0] is the horizontal coordinate\n                  s[1] is the vertical coordinate",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "demo_heuristic_lander",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "def demo_heuristic_lander(env, seed=None, render=False):\n    total_reward = 0\n    steps = 0\n    s = env.reset(seed=seed)\n    while True:\n        a = heuristic(env, s)\n        s, r, done, info = env.step(a)\n        total_reward += r\n        if render:\n            still_open = env.render()",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "__credits__ = [\"Andrea PIERR\"]\nimport math\nfrom typing import Optional\nimport numpy as np\nimport gym\nfrom gym import error, spaces\nfrom gym.error import DependencyNotInstalled\nfrom gym.utils import EzPickle\ntry:\n    import Box2D",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "FPS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "FPS = 50\nSCALE = 30.0  # affects how fast-paced the game is, forces should be adjusted as well\nMAIN_ENGINE_POWER = 13.0\nSIDE_ENGINE_POWER = 0.6\nINITIAL_RANDOM = 1000.0  # Set 1500 to make game harder\nLANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "SCALE = 30.0  # affects how fast-paced the game is, forces should be adjusted as well\nMAIN_ENGINE_POWER = 13.0\nSIDE_ENGINE_POWER = 0.6\nINITIAL_RANDOM = 1000.0  # Set 1500 to make game harder\nLANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "MAIN_ENGINE_POWER",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "MAIN_ENGINE_POWER = 13.0\nSIDE_ENGINE_POWER = 0.6\nINITIAL_RANDOM = 1000.0  # Set 1500 to make game harder\nLANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "SIDE_ENGINE_POWER",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "SIDE_ENGINE_POWER = 0.6\nINITIAL_RANDOM = 1000.0  # Set 1500 to make game harder\nLANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "INITIAL_RANDOM",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "INITIAL_RANDOM = 1000.0  # Set 1500 to make game harder\nLANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LANDER_POLY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "LANDER_POLY = [(-14, +17), (-17, 0), (-17, -10), (+17, -10), (+17, 0), (+14, +17)]\nLEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LEG_AWAY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "LEG_AWAY = 20\nLEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LEG_DOWN",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "LEG_DOWN = 18\nLEG_W, LEG_H = 2, 8\nLEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "LEG_SPRING_TORQUE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "LEG_SPRING_TORQUE = 40\nSIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "SIDE_ENGINE_HEIGHT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "SIDE_ENGINE_HEIGHT = 14.0\nSIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "SIDE_ENGINE_AWAY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "SIDE_ENGINE_AWAY = 12.0\nVIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (\n            self.env.lander == contact.fixtureA.body",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "VIEWPORT_W",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "VIEWPORT_W = 600\nVIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (\n            self.env.lander == contact.fixtureA.body\n            or self.env.lander == contact.fixtureB.body",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "VIEWPORT_H",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "description": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "peekOfCode": "VIEWPORT_H = 400\nclass ContactDetector(contactListener):\n    def __init__(self, env):\n        contactListener.__init__(self)\n        self.env = env\n    def BeginContact(self, contact):\n        if (\n            self.env.lander == contact.fixtureA.body\n            or self.env.lander == contact.fixtureB.body\n        ):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.box2d.lunar_lander",
        "documentation": {}
    },
    {
        "label": "AcrobotEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "class AcrobotEnv(core.Env):\n    \"\"\"\n    ### Description\n    The Acrobot environment is based on Sutton's work in\n    [\"Generalization in Reinforcement Learning: Successful Examples Using Sparse Coarse Coding\"](https://papers.nips.cc/paper/1995/hash/8f1d43620bc6bb580df6e80b0dc05c48-Abstract.html)\n    and [Sutton and Barto's book](http://www.incompleteideas.net/book/the-book-2nd.html).\n    The system consists of two links connected linearly to form a chain, with one end of\n    the chain fixed. The joint between the two links is actuated. The goal is to apply\n    torques on the actuated joint to swing the free end of the linear chain above a\n    given height while starting from the initial state of hanging downwards.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "wrap",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "def wrap(x, m, M):\n    \"\"\"Wraps ``x`` so m <= x <= M; but unlike ``bound()`` which\n    truncates, ``wrap()`` wraps x around the coordinate system defined by m,M.\\n\n    For example, m = -180, M = 180 (degrees), x = 360 --> returns 0.\n    Args:\n        x: a scalar\n        m: minimum possible value in range\n        M: maximum possible value in range\n    Returns:\n        x: a scalar, wrapped",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "bound",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "def bound(x, m, M=None):\n    \"\"\"Either have m as scalar, so bound(x,m,M) which returns m <= x <= M *OR*\n    have m as length 2 vector, bound(x,m, <IGNORED>) returns m[0] <= x <= m[1].\n    Args:\n        x: scalar\n    Returns:\n        x: scalar, bound between min (m) and Max (M)\n    \"\"\"\n    if M is None:\n        M = m[1]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "rk4",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "def rk4(derivs, y0, t):\n    \"\"\"\n    Integrate 1-D or N-D system of ODEs using 4-th order Runge-Kutta.\n    This is a toy implementation which may be useful if you find\n    yourself stranded on a system w/o scipy.  Otherwise use\n    :func:`scipy.integrate`.\n    Args:\n        derivs: the derivative of the system and has the signature ``dy = derivs(yi)``\n        y0: initial state vector\n        t: sample times",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "__copyright__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "__copyright__ = \"Copyright 2013, RLPy http://acl.mit.edu/RLPy\"\n__credits__ = [\n    \"Alborz Geramifard\",\n    \"Robert H. Klein\",\n    \"Christoph Dann\",\n    \"William Dabney\",\n    \"Jonathan P. How\",\n]\n__license__ = \"BSD 3-Clause\"\n__author__ = \"Christoph Dann <cdann@cdann.de>\"",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "__credits__ = [\n    \"Alborz Geramifard\",\n    \"Robert H. Klein\",\n    \"Christoph Dann\",\n    \"William Dabney\",\n    \"Jonathan P. How\",\n]\n__license__ = \"BSD 3-Clause\"\n__author__ = \"Christoph Dann <cdann@cdann.de>\"\n# SOURCE:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "__license__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "__license__ = \"BSD 3-Clause\"\n__author__ = \"Christoph Dann <cdann@cdann.de>\"\n# SOURCE:\n# https://github.com/rlpy/rlpy/blob/master/rlpy/Domains/Acrobot.py\nclass AcrobotEnv(core.Env):\n    \"\"\"\n    ### Description\n    The Acrobot environment is based on Sutton's work in\n    [\"Generalization in Reinforcement Learning: Successful Examples Using Sparse Coarse Coding\"](https://papers.nips.cc/paper/1995/hash/8f1d43620bc6bb580df6e80b0dc05c48-Abstract.html)\n    and [Sutton and Barto's book](http://www.incompleteideas.net/book/the-book-2nd.html).",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "peekOfCode": "__author__ = \"Christoph Dann <cdann@cdann.de>\"\n# SOURCE:\n# https://github.com/rlpy/rlpy/blob/master/rlpy/Domains/Acrobot.py\nclass AcrobotEnv(core.Env):\n    \"\"\"\n    ### Description\n    The Acrobot environment is based on Sutton's work in\n    [\"Generalization in Reinforcement Learning: Successful Examples Using Sparse Coarse Coding\"](https://papers.nips.cc/paper/1995/hash/8f1d43620bc6bb580df6e80b0dc05c48-Abstract.html)\n    and [Sutton and Barto's book](http://www.incompleteideas.net/book/the-book-2nd.html).\n    The system consists of two links connected linearly to form a chain, with one end of",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.acrobot",
        "documentation": {}
    },
    {
        "label": "CartPoleEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.cartpole",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.cartpole",
        "peekOfCode": "class CartPoleEnv(gym.Env[np.ndarray, Union[int, np.ndarray]]):\n    \"\"\"\n    ### Description\n    This environment corresponds to the version of the cart-pole problem\n    described by Barto, Sutton, and Anderson in [\"Neuronlike Adaptive Elements That Can Solve Difficult Learning Control Problem\"](https://ieeexplore.ieee.org/document/6313077).\n    A pole is attached by an un-actuated joint to a cart, which moves along a\n    frictionless track. The pendulum is placed upright on the cart and the goal is to balance the pole by applying forces in the left and right direction on the cart.\n    ### Action Space\n    The action is a `ndarray` with shape `(1,)` which can take values `{0, 1}` indicating the direction of the fixed force the cart is pushed with.\n    | Num | Action                 |",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.cartpole",
        "documentation": {}
    },
    {
        "label": "Continuous_MountainCarEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.continuous_mountain_car",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.continuous_mountain_car",
        "peekOfCode": "class Continuous_MountainCarEnv(gym.Env):\n    \"\"\"\n    ### Description\n    The Mountain Car MDP is a deterministic MDP that consists of a car placed stochastically\n    at the bottom of a sinusoidal valley, with the only possible actions being the accelerations\n    that can be applied to the car in either direction. The goal of the MDP is to strategically\n    accelerate the car to reach the goal state on top of the right hill. There are two versions\n    of the mountain car domain in gym: one with discrete actions and one with continuous.\n    This version is the one with continuous actions.\n    This MDP first appeared in [Andrew Moore's PhD Thesis (1990)](https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-209.pdf)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.continuous_mountain_car",
        "documentation": {}
    },
    {
        "label": "MountainCarEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.mountain_car",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.mountain_car",
        "peekOfCode": "class MountainCarEnv(gym.Env):\n    \"\"\"\n    ### Description\n    The Mountain Car MDP is a deterministic MDP that consists of a car placed stochastically\n    at the bottom of a sinusoidal valley, with the only possible actions being the accelerations\n    that can be applied to the car in either direction. The goal of the MDP is to strategically\n    accelerate the car to reach the goal state on top of the right hill. There are two versions\n    of the mountain car domain in gym: one with discrete actions and one with continuous.\n    This version is the one with discrete actions.\n    This MDP first appeared in [Andrew Moore's PhD Thesis (1990)](https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-209.pdf)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.mountain_car",
        "documentation": {}
    },
    {
        "label": "PendulumEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "peekOfCode": "class PendulumEnv(gym.Env):\n    \"\"\"\n       ### Description\n    The inverted pendulum swingup problem is based on the classic problem in control theory. The system consists of a pendulum attached at one end to a fixed point, and the other end being free. The pendulum starts in a random position and the goal is to apply torque on the free end to swing it into an upright position, with its center of gravity right above the fixed point.\n    The diagram below specifies the coordinate system used for the implementation of the pendulum's\n    dynamic equations.\n    ![Pendulum Coordinate System](./diagrams/pendulum.png)\n    -  `x-y`: cartesian coordinates of the pendulum's end in meters.\n    - `theta` : angle in radians.\n    - `tau`: torque in `N m`. Defined as positive _counter-clockwise_.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "documentation": {}
    },
    {
        "label": "angle_normalize",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "peekOfCode": "def angle_normalize(x):\n    return ((x + np.pi) % (2 * np.pi)) - np.pi",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "description": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "peekOfCode": "__credits__ = [\"Carlos Luis\"]\nfrom os import path\nfrom typing import Optional\nimport numpy as np\nimport gym\nfrom gym import spaces\nfrom gym.error import DependencyNotInstalled\nclass PendulumEnv(gym.Env):\n    \"\"\"\n       ### Description",
        "detail": "repos_that_could_be_useful.gym.gym.envs.classic_control.pendulum",
        "documentation": {}
    },
    {
        "label": "AntEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant",
        "peekOfCode": "class AntEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"ant.xml\", 5)\n        utils.EzPickle.__init__(self)\n    def step(self, a):\n        xposbefore = self.get_body_com(\"torso\")[0]\n        self.do_simulation(a, self.frame_skip)\n        xposafter = self.get_body_com(\"torso\")[0]\n        forward_reward = (xposafter - xposbefore) / self.dt\n        ctrl_cost = 0.5 * np.square(a).sum()",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant",
        "documentation": {}
    },
    {
        "label": "AntEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "peekOfCode": "class AntEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the environment introduced by Schulman,\n    Moritz, Levine, Jordan and Abbeel in [\"High-Dimensional Continuous Control\n    Using Generalized Advantage Estimation\"](https://arxiv.org/abs/1506.02438).\n    The ant is a 3D robot consisting of one torso (free rotational body) with\n    four legs attached to it with each leg having two links. The goal is to\n    coordinate the four legs to move in the forward (right) direction by applying\n    torques on the eight hinges connecting the two links of each leg and the torso",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {\n    \"distance\": 4.0,\n}\nclass AntEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the environment introduced by Schulman,\n    Moritz, Levine, Jordan and Abbeel in [\"High-Dimensional Continuous Control\n    Using Generalized Advantage Estimation\"](https://arxiv.org/abs/1506.02438).\n    The ant is a 3D robot consisting of one torso (free rotational body) with",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.ant_v3",
        "documentation": {}
    },
    {
        "label": "HalfCheetahEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah",
        "peekOfCode": "class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"half_cheetah.xml\", 5)\n        utils.EzPickle.__init__(self)\n    def step(self, action):\n        xposbefore = self.sim.data.qpos[0]\n        self.do_simulation(action, self.frame_skip)\n        xposafter = self.sim.data.qpos[0]\n        ob = self._get_obs()\n        reward_ctrl = -0.1 * np.square(action).sum()",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah",
        "documentation": {}
    },
    {
        "label": "HalfCheetahEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "peekOfCode": "class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the work by P. Wawrzynski in\n    [\"A Cat-Like Robot Real-Time Learning to Run\"](http://staff.elka.pw.edu.pl/~pwawrzyn/pub-s/0812_LSCLRR.pdf).\n    The HalfCheetah is a 2-dimensional robot consisting of 9 links and 8\n    joints connecting them (including two paws). The goal is to apply a torque\n    on the joints to make the cheetah run forward (right) as fast as possible,\n    with a positive reward allocated based on the distance moved forward and a\n    negative reward allocated for moving backward. The torso and head of the",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "peekOfCode": "__credits__ = [\"Rushiv Arora\"]\nimport numpy as np\nfrom gym import utils\nfrom gym.envs.mujoco import mujoco_env\nDEFAULT_CAMERA_CONFIG = {\n    \"distance\": 4.0,\n}\nclass HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {\n    \"distance\": 4.0,\n}\nclass HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the work by P. Wawrzynski in\n    [\"A Cat-Like Robot Real-Time Learning to Run\"](http://staff.elka.pw.edu.pl/~pwawrzyn/pub-s/0812_LSCLRR.pdf).\n    The HalfCheetah is a 2-dimensional robot consisting of 9 links and 8\n    joints connecting them (including two paws). The goal is to apply a torque",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.half_cheetah_v3",
        "documentation": {}
    },
    {
        "label": "HopperEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper",
        "peekOfCode": "class HopperEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"hopper.xml\", 4)\n        utils.EzPickle.__init__(self)\n    def step(self, a):\n        posbefore = self.sim.data.qpos[0]\n        self.do_simulation(a, self.frame_skip)\n        posafter, height, ang = self.sim.data.qpos[0:3]\n        alive_bonus = 1.0\n        reward = (posafter - posbefore) / self.dt",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper",
        "documentation": {}
    },
    {
        "label": "HopperEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "peekOfCode": "class HopperEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the work done by Erez, Tassa, and Todorov in\n    [\"Infinite Horizon Model Predictive Control for Nonlinear Periodic Tasks\"](http://www.roboticsproceedings.org/rss07/p10.pdf). The environment aims to\n    increase the number of independent state and control variables as compared to\n    the classic control environments. The hopper is a two-dimensional\n    one-legged figure that consist of four main body parts - the torso at the\n    top, the thigh in the middle, the leg in the bottom, and a single foot on\n    which the entire body rests. The goal is to make hops that move in the",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "peekOfCode": "__credits__ = [\"Rushiv Arora\"]\nimport numpy as np\nfrom gym import utils\nfrom gym.envs.mujoco import mujoco_env\nDEFAULT_CAMERA_CONFIG = {\n    \"trackbodyid\": 2,\n    \"distance\": 3.0,\n    \"lookat\": np.array((0.0, 0.0, 1.15)),\n    \"elevation\": -20.0,\n}",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {\n    \"trackbodyid\": 2,\n    \"distance\": 3.0,\n    \"lookat\": np.array((0.0, 0.0, 1.15)),\n    \"elevation\": -20.0,\n}\nclass HopperEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the work done by Erez, Tassa, and Todorov in",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.hopper_v3",
        "documentation": {}
    },
    {
        "label": "HumanoidEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "peekOfCode": "class HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"humanoid.xml\", 5)\n        utils.EzPickle.__init__(self)\n    def _get_obs(self):\n        data = self.sim.data\n        return np.concatenate(\n            [\n                data.qpos.flat[2:],\n                data.qvel.flat,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "documentation": {}
    },
    {
        "label": "mass_center",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "peekOfCode": "def mass_center(model, sim):\n    mass = np.expand_dims(model.body_mass, 1)\n    xpos = sim.data.xipos\n    return (np.sum(mass * xpos, 0) / np.sum(mass))[0]\nclass HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"humanoid.xml\", 5)\n        utils.EzPickle.__init__(self)\n    def _get_obs(self):\n        data = self.sim.data",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid",
        "documentation": {}
    },
    {
        "label": "HumanoidEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "peekOfCode": "class HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the environment introduced by Tassa, Erez and Todorov\n    in [\"Synthesis and stabilization of complex behaviors through online trajectory optimization\"](https://ieeexplore.ieee.org/document/6386025).\n    The 3D bipedal robot is designed to simulate a human. It has a torso (abdomen) with a pair of\n    legs and arms. The legs each consist of two links, and so the arms (representing the knees and\n    elbows respectively). The goal of the environment is to walk forward as fast as possible without falling over.\n    ### Action Space\n    The action space is a `Box(-1, 1, (17,), float32)`. An action represents the torques applied at the hinge joints.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "documentation": {}
    },
    {
        "label": "mass_center",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "peekOfCode": "def mass_center(model, sim):\n    mass = np.expand_dims(model.body_mass, axis=1)\n    xpos = sim.data.xipos\n    return (np.sum(mass * xpos, axis=0) / np.sum(mass))[0:2].copy()\nclass HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the environment introduced by Tassa, Erez and Todorov\n    in [\"Synthesis and stabilization of complex behaviors through online trajectory optimization\"](https://ieeexplore.ieee.org/document/6386025).\n    The 3D bipedal robot is designed to simulate a human. It has a torso (abdomen) with a pair of",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {\n    \"trackbodyid\": 1,\n    \"distance\": 4.0,\n    \"lookat\": np.array((0.0, 0.0, 2.0)),\n    \"elevation\": -20.0,\n}\ndef mass_center(model, sim):\n    mass = np.expand_dims(model.body_mass, axis=1)\n    xpos = sim.data.xipos\n    return (np.sum(mass * xpos, axis=0) / np.sum(mass))[0:2].copy()",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoid_v3",
        "documentation": {}
    },
    {
        "label": "HumanoidStandupEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoidstandup",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoidstandup",
        "peekOfCode": "class HumanoidStandupEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is based on the environment introduced by Tassa, Erez and Todorov\n    in [\"Synthesis and stabilization of complex behaviors through online trajectory optimization\"](https://ieeexplore.ieee.org/document/6386025).\n    The 3D bipedal robot is designed to simulate a human. It has a torso (abdomen) with a\n    pair of legs and arms. The legs each consist of two links, and so the arms (representing the\n    knees and elbows respectively). The environment starts with the humanoid layiing on the ground,\n    and then the goal of the environment is to make the humanoid standup and then keep it standing\n    by applying torques on the various hinges.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.humanoidstandup",
        "documentation": {}
    },
    {
        "label": "InvertedDoublePendulumEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_double_pendulum",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_double_pendulum",
        "peekOfCode": "class InvertedDoublePendulumEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment originates from control theory and builds on the cartpole\n    environment based on the work done by Barto, Sutton, and Anderson in\n    [\"Neuronlike adaptive elements that can solve difficult learning control problems\"](https://ieeexplore.ieee.org/document/6313077),\n    powered by the Mujoco physics simulator - allowing for more complex experiments\n    (such as varying the effects of gravity or constraints). This environment involves a cart that can\n    moved linearly, with a pole fixed on it and a second pole fixed on the other end of the first one\n    (leaving the second pole as the only one with one free end). The cart can be pushed left or right,",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_double_pendulum",
        "documentation": {}
    },
    {
        "label": "InvertedPendulumEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_pendulum",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_pendulum",
        "peekOfCode": "class InvertedPendulumEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment is the cartpole environment based on the work done by\n    Barto, Sutton, and Anderson in [\"Neuronlike adaptive elements that can\n    solve difficult learning control problems\"](https://ieeexplore.ieee.org/document/6313077),\n    just like in the classic environments but now powered by the Mujoco physics simulator -\n    allowing for more complex experiments (such as varying the effects of gravity).\n    This environment involves a cart that can moved linearly, with a pole fixed on it\n    at one end and having another end free. The cart can be pushed left or right, and the",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.inverted_pendulum",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "peekOfCode": "class MujocoEnv(gym.Env):\n    \"\"\"Superclass for all MuJoCo environments.\"\"\"\n    def __init__(self, model_path, frame_skip):\n        if model_path.startswith(\"/\"):\n            fullpath = model_path\n        else:\n            fullpath = os.path.join(os.path.dirname(__file__), \"assets\", model_path)\n        if not path.exists(fullpath):\n            raise OSError(f\"File {fullpath} does not exist\")\n        self.frame_skip = frame_skip",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "documentation": {}
    },
    {
        "label": "convert_observation_to_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "peekOfCode": "def convert_observation_to_space(observation):\n    if isinstance(observation, dict):\n        space = spaces.Dict(\n            OrderedDict(\n                [\n                    (key, convert_observation_to_space(value))\n                    for key, value in observation.items()\n                ]\n            )\n        )",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SIZE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "peekOfCode": "DEFAULT_SIZE = 500\ndef convert_observation_to_space(observation):\n    if isinstance(observation, dict):\n        space = spaces.Dict(\n            OrderedDict(\n                [\n                    (key, convert_observation_to_space(value))\n                    for key, value in observation.items()\n                ]\n            )",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.mujoco_env",
        "documentation": {}
    },
    {
        "label": "PusherEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.pusher",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.pusher",
        "peekOfCode": "class PusherEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    \"Pusher\" is a multi-jointed robot arm which is very similar to that of a human.\n     The goal is to move a target cylinder (called *object*) to a goal position using the robot's end effector (called *fingertip*).\n      The robot consists of shoulder, elbow, forearm, and wrist joints.\n    ### Action Space\n    The action space is a `Box(-2, 2, (7,), float32)`. An action `(a, b)` represents the torques applied at the hinge joints.\n    | Num | Action                                                             | Control Min | Control Max | Name (in corresponding XML file) | Joint | Unit         |\n    |-----|--------------------------------------------------------------------|-------------|-------------|----------------------------------|-------|--------------|",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.pusher",
        "documentation": {}
    },
    {
        "label": "ReacherEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.reacher",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.reacher",
        "peekOfCode": "class ReacherEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    \"Reacher\" is a two-jointed robot arm. The goal is to move the robot's end effector (called *fingertip*) close to a\n    target that is spawned at a random position.\n    ### Action Space\n    The action space is a `Box(-1, 1, (2,), float32)`. An action `(a, b)` represents the torques applied at the hinge joints.\n    | Num | Action                                                                          | Control Min | Control Max | Name (in corresponding XML file) | Joint | Unit |\n    |-----|---------------------------------------------------------------------------------|-------------|-------------|--------------------------|-------|------|\n    | 0   | Torque applied at the first hinge (connecting the link to the point of fixture) | -1 | 1 | joint0  | hinge | torque (N m) |",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.reacher",
        "documentation": {}
    },
    {
        "label": "SwimmerEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer",
        "peekOfCode": "class SwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"swimmer.xml\", 4)\n        utils.EzPickle.__init__(self)\n    def step(self, a):\n        ctrl_cost_coeff = 0.0001\n        xposbefore = self.sim.data.qpos[0]\n        self.do_simulation(a, self.frame_skip)\n        xposafter = self.sim.data.qpos[0]\n        reward_fwd = (xposafter - xposbefore) / self.dt",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer",
        "documentation": {}
    },
    {
        "label": "SwimmerEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "peekOfCode": "class SwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment corresponds to the Swimmer environment described in Rmi Coulom's PhD thesis\n    [\"Reinforcement Learning Using Neural Networks, with Applications to Motor Control\"](https://tel.archives-ouvertes.fr/tel-00003985/document).\n    The environment aims to increase the number of independent state and control\n    variables as compared to the classic control environments. The swimmers\n    consist of three or more segments ('***links***') and one less articulation\n    joints ('***rotors***') - one rotor joint connecting exactly two links to\n    form a linear chain. The swimmer is suspended in a two dimensional pool and",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "documentation": {}
    },
    {
        "label": "__credits__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "peekOfCode": "__credits__ = [\"Rushiv Arora\"]\nimport numpy as np\nfrom gym import utils\nfrom gym.envs.mujoco import mujoco_env\nDEFAULT_CAMERA_CONFIG = {}\nclass SwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment corresponds to the Swimmer environment described in Rmi Coulom's PhD thesis\n    [\"Reinforcement Learning Using Neural Networks, with Applications to Motor Control\"](https://tel.archives-ouvertes.fr/tel-00003985/document).",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {}\nclass SwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment corresponds to the Swimmer environment described in Rmi Coulom's PhD thesis\n    [\"Reinforcement Learning Using Neural Networks, with Applications to Motor Control\"](https://tel.archives-ouvertes.fr/tel-00003985/document).\n    The environment aims to increase the number of independent state and control\n    variables as compared to the classic control environments. The swimmers\n    consist of three or more segments ('***links***') and one less articulation\n    joints ('***rotors***') - one rotor joint connecting exactly two links to",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.swimmer_v3",
        "documentation": {}
    },
    {
        "label": "Walker2dEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d",
        "peekOfCode": "class Walker2dEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    def __init__(self):\n        mujoco_env.MujocoEnv.__init__(self, \"walker2d.xml\", 4)\n        utils.EzPickle.__init__(self)\n    def step(self, a):\n        posbefore = self.sim.data.qpos[0]\n        self.do_simulation(a, self.frame_skip)\n        posafter, height, ang = self.sim.data.qpos[0:3]\n        alive_bonus = 1.0\n        reward = (posafter - posbefore) / self.dt",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d",
        "documentation": {}
    },
    {
        "label": "Walker2dEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "peekOfCode": "class Walker2dEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment builds on the hopper environment based on the work done by Erez, Tassa, and Todorov\n    in [\"Infinite Horizon Model Predictive Control for Nonlinear Periodic Tasks\"](http://www.roboticsproceedings.org/rss07/p10.pdf)\n    by adding another set of legs making it possible for the robot to walker forward instead of\n    hop. Like other Mujoco environments, this environment aims to increase the number of independent state\n    and control variables as compared to the classic control environments. The walker is a\n    two-dimensional two-legged figure that consist of four main body parts - a single torso at the top\n    (with the two legs splitting after the torso), two thighs in the middle below the torso, two legs",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_CONFIG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "description": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "peekOfCode": "DEFAULT_CAMERA_CONFIG = {\n    \"trackbodyid\": 2,\n    \"distance\": 4.0,\n    \"lookat\": np.array((0.0, 0.0, 1.15)),\n    \"elevation\": -20.0,\n}\nclass Walker2dEnv(mujoco_env.MujocoEnv, utils.EzPickle):\n    \"\"\"\n    ### Description\n    This environment builds on the hopper environment based on the work done by Erez, Tassa, and Todorov",
        "detail": "repos_that_could_be_useful.gym.gym.envs.mujoco.walker2d_v3",
        "documentation": {}
    },
    {
        "label": "BlackjackEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "class BlackjackEnv(gym.Env):\n    \"\"\"\n    Blackjack is a card game where the goal is to beat the dealer by obtaining cards\n    that sum to closer to 21 (without going over 21) than the dealers cards.\n    ### Description\n    Card Values:\n    - Face cards (Jack, Queen, King) have a point value of 10.\n    - Aces can either count as 11 (called a 'usable ace') or 1.\n    - Numerical cards (2-9) have a value equal to their number.\n    This game is played with an infinite deck (or with replacement).",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "cmp",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def cmp(a, b):\n    return float(a > b) - float(a < b)\n# 1 = Ace, 2-10 = Number cards, Jack/Queen/King = 10\ndeck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10]\ndef draw_card(np_random):\n    return int(np_random.choice(deck))\ndef draw_hand(np_random):\n    return [draw_card(np_random), draw_card(np_random)]\ndef usable_ace(hand):  # Does this hand have a usable ace?\n    return 1 in hand and sum(hand) + 10 <= 21",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "draw_card",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def draw_card(np_random):\n    return int(np_random.choice(deck))\ndef draw_hand(np_random):\n    return [draw_card(np_random), draw_card(np_random)]\ndef usable_ace(hand):  # Does this hand have a usable ace?\n    return 1 in hand and sum(hand) + 10 <= 21\ndef sum_hand(hand):  # Return current hand total\n    if usable_ace(hand):\n        return sum(hand) + 10\n    return sum(hand)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "draw_hand",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def draw_hand(np_random):\n    return [draw_card(np_random), draw_card(np_random)]\ndef usable_ace(hand):  # Does this hand have a usable ace?\n    return 1 in hand and sum(hand) + 10 <= 21\ndef sum_hand(hand):  # Return current hand total\n    if usable_ace(hand):\n        return sum(hand) + 10\n    return sum(hand)\ndef is_bust(hand):  # Is this hand a bust?\n    return sum_hand(hand) > 21",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "usable_ace",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def usable_ace(hand):  # Does this hand have a usable ace?\n    return 1 in hand and sum(hand) + 10 <= 21\ndef sum_hand(hand):  # Return current hand total\n    if usable_ace(hand):\n        return sum(hand) + 10\n    return sum(hand)\ndef is_bust(hand):  # Is this hand a bust?\n    return sum_hand(hand) > 21\ndef score(hand):  # What is the score of this hand (0 if bust)\n    return 0 if is_bust(hand) else sum_hand(hand)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "sum_hand",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def sum_hand(hand):  # Return current hand total\n    if usable_ace(hand):\n        return sum(hand) + 10\n    return sum(hand)\ndef is_bust(hand):  # Is this hand a bust?\n    return sum_hand(hand) > 21\ndef score(hand):  # What is the score of this hand (0 if bust)\n    return 0 if is_bust(hand) else sum_hand(hand)\ndef is_natural(hand):  # Is this hand a natural blackjack?\n    return sorted(hand) == [1, 10]",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "is_bust",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def is_bust(hand):  # Is this hand a bust?\n    return sum_hand(hand) > 21\ndef score(hand):  # What is the score of this hand (0 if bust)\n    return 0 if is_bust(hand) else sum_hand(hand)\ndef is_natural(hand):  # Is this hand a natural blackjack?\n    return sorted(hand) == [1, 10]\nclass BlackjackEnv(gym.Env):\n    \"\"\"\n    Blackjack is a card game where the goal is to beat the dealer by obtaining cards\n    that sum to closer to 21 (without going over 21) than the dealers cards.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def score(hand):  # What is the score of this hand (0 if bust)\n    return 0 if is_bust(hand) else sum_hand(hand)\ndef is_natural(hand):  # Is this hand a natural blackjack?\n    return sorted(hand) == [1, 10]\nclass BlackjackEnv(gym.Env):\n    \"\"\"\n    Blackjack is a card game where the goal is to beat the dealer by obtaining cards\n    that sum to closer to 21 (without going over 21) than the dealers cards.\n    ### Description\n    Card Values:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "is_natural",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "def is_natural(hand):  # Is this hand a natural blackjack?\n    return sorted(hand) == [1, 10]\nclass BlackjackEnv(gym.Env):\n    \"\"\"\n    Blackjack is a card game where the goal is to beat the dealer by obtaining cards\n    that sum to closer to 21 (without going over 21) than the dealers cards.\n    ### Description\n    Card Values:\n    - Face cards (Jack, Queen, King) have a point value of 10.\n    - Aces can either count as 11 (called a 'usable ace') or 1.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "deck",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "peekOfCode": "deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10]\ndef draw_card(np_random):\n    return int(np_random.choice(deck))\ndef draw_hand(np_random):\n    return [draw_card(np_random), draw_card(np_random)]\ndef usable_ace(hand):  # Does this hand have a usable ace?\n    return 1 in hand and sum(hand) + 10 <= 21\ndef sum_hand(hand):  # Return current hand total\n    if usable_ace(hand):\n        return sum(hand) + 10",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.blackjack",
        "documentation": {}
    },
    {
        "label": "CliffWalkingEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "peekOfCode": "class CliffWalkingEnv(Env):\n    \"\"\"\n    This is a simple implementation of the Gridworld Cliff\n    reinforcement learning task.\n    Adapted from Example 6.6 (page 106) from [Reinforcement Learning: An Introduction\n    by Sutton and Barto](http://incompleteideas.net/book/bookdraft2018jan1.pdf).\n    With inspiration from:\n    https://github.com/dennybritz/reinforcement-learning/blob/master/lib/envs/cliff_walking.py\n    ### Description\n    The board is a 4x12 matrix, with (using NumPy matrix indexing):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "documentation": {}
    },
    {
        "label": "UP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "peekOfCode": "UP = 0\nRIGHT = 1\nDOWN = 2\nLEFT = 3\nclass CliffWalkingEnv(Env):\n    \"\"\"\n    This is a simple implementation of the Gridworld Cliff\n    reinforcement learning task.\n    Adapted from Example 6.6 (page 106) from [Reinforcement Learning: An Introduction\n    by Sutton and Barto](http://incompleteideas.net/book/bookdraft2018jan1.pdf).",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "documentation": {}
    },
    {
        "label": "RIGHT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "peekOfCode": "RIGHT = 1\nDOWN = 2\nLEFT = 3\nclass CliffWalkingEnv(Env):\n    \"\"\"\n    This is a simple implementation of the Gridworld Cliff\n    reinforcement learning task.\n    Adapted from Example 6.6 (page 106) from [Reinforcement Learning: An Introduction\n    by Sutton and Barto](http://incompleteideas.net/book/bookdraft2018jan1.pdf).\n    With inspiration from:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "documentation": {}
    },
    {
        "label": "DOWN",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "peekOfCode": "DOWN = 2\nLEFT = 3\nclass CliffWalkingEnv(Env):\n    \"\"\"\n    This is a simple implementation of the Gridworld Cliff\n    reinforcement learning task.\n    Adapted from Example 6.6 (page 106) from [Reinforcement Learning: An Introduction\n    by Sutton and Barto](http://incompleteideas.net/book/bookdraft2018jan1.pdf).\n    With inspiration from:\n    https://github.com/dennybritz/reinforcement-learning/blob/master/lib/envs/cliff_walking.py",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "documentation": {}
    },
    {
        "label": "LEFT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "peekOfCode": "LEFT = 3\nclass CliffWalkingEnv(Env):\n    \"\"\"\n    This is a simple implementation of the Gridworld Cliff\n    reinforcement learning task.\n    Adapted from Example 6.6 (page 106) from [Reinforcement Learning: An Introduction\n    by Sutton and Barto](http://incompleteideas.net/book/bookdraft2018jan1.pdf).\n    With inspiration from:\n    https://github.com/dennybritz/reinforcement-learning/blob/master/lib/envs/cliff_walking.py\n    ### Description",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.cliffwalking",
        "documentation": {}
    },
    {
        "label": "FrozenLakeEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "class FrozenLakeEnv(Env):\n    \"\"\"\n    Frozen lake involves crossing a frozen lake from Start(S) to Goal(G) without falling into any Holes(H) by walking over\n    the Frozen(F) lake. The agent may not always move in the intended direction due to the slippery nature of the frozen lake.\n    ### Action Space\n    The agent takes a 1-element vector for actions.\n    The action space is `(dir)`, where `dir` decides direction to move in which can be:\n    - 0: LEFT\n    - 1: DOWN\n    - 2: RIGHT",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "generate_random_map",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "def generate_random_map(size=8, p=0.8):\n    \"\"\"Generates a random valid map (one that has a path from start to goal)\n    :param size: size of each side of the grid\n    :param p: probability that a tile is frozen\n    \"\"\"\n    valid = False\n    # DFS to check that it's a valid path.\n    def is_valid(res):\n        frontier, discovered = [], set()\n        frontier.append((0, 0))",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "LEFT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "LEFT = 0\nDOWN = 1\nRIGHT = 2\nUP = 3\nMAPS = {\n    \"4x4\": [\"SFFF\", \"FHFH\", \"FFFH\", \"HFFG\"],\n    \"8x8\": [\n        \"SFFFFFFF\",\n        \"FFFFFFFF\",\n        \"FFFHFFFF\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "DOWN",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "DOWN = 1\nRIGHT = 2\nUP = 3\nMAPS = {\n    \"4x4\": [\"SFFF\", \"FHFH\", \"FFFH\", \"HFFG\"],\n    \"8x8\": [\n        \"SFFFFFFF\",\n        \"FFFFFFFF\",\n        \"FFFHFFFF\",\n        \"FFFFFHFF\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "RIGHT",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "RIGHT = 2\nUP = 3\nMAPS = {\n    \"4x4\": [\"SFFF\", \"FHFH\", \"FFFH\", \"HFFG\"],\n    \"8x8\": [\n        \"SFFFFFFF\",\n        \"FFFFFFFF\",\n        \"FFFHFFFF\",\n        \"FFFFFHFF\",\n        \"FFFHFFFF\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "UP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "UP = 3\nMAPS = {\n    \"4x4\": [\"SFFF\", \"FHFH\", \"FFFH\", \"HFFG\"],\n    \"8x8\": [\n        \"SFFFFFFF\",\n        \"FFFFFFFF\",\n        \"FFFHFFFF\",\n        \"FFFFFHFF\",\n        \"FFFHFFFF\",\n        \"FHHFFFHF\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "MAPS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "peekOfCode": "MAPS = {\n    \"4x4\": [\"SFFF\", \"FHFH\", \"FFFH\", \"HFFG\"],\n    \"8x8\": [\n        \"SFFFFFFF\",\n        \"FFFFFFFF\",\n        \"FFFHFFFF\",\n        \"FFFFFHFF\",\n        \"FFFHFFFF\",\n        \"FHHFFFHF\",\n        \"FHFFHFHF\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.frozen_lake",
        "documentation": {}
    },
    {
        "label": "TaxiEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "peekOfCode": "class TaxiEnv(Env):\n    \"\"\"\n    The Taxi Problem\n    from \"Hierarchical Reinforcement Learning with the MAXQ Value Function Decomposition\"\n    by Tom Dietterich\n    ### Description\n    There are four designated locations in the grid world indicated by R(ed),\n    G(reen), Y(ellow), and B(lue). When the episode starts, the taxi starts off\n    at a random square and the passenger is at a random location. The taxi\n    drives to the passenger's location, picks up the passenger, drives to the",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "peekOfCode": "MAP = [\n    \"+---------+\",\n    \"|R: | : :G|\",\n    \"| : | : : |\",\n    \"| : : : : |\",\n    \"| | : | : |\",\n    \"|Y| : |B: |\",\n    \"+---------+\",\n]\nWINDOW_SIZE = (550, 350)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "documentation": {}
    },
    {
        "label": "WINDOW_SIZE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "peekOfCode": "WINDOW_SIZE = (550, 350)\nclass TaxiEnv(Env):\n    \"\"\"\n    The Taxi Problem\n    from \"Hierarchical Reinforcement Learning with the MAXQ Value Function Decomposition\"\n    by Tom Dietterich\n    ### Description\n    There are four designated locations in the grid world indicated by R(ed),\n    G(reen), Y(ellow), and B(lue). When the episode starts, the taxi starts off\n    at a random square and the passenger is at a random location. The taxi",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.taxi",
        "documentation": {}
    },
    {
        "label": "categorical_sample",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.toy_text.utils",
        "description": "repos_that_could_be_useful.gym.gym.envs.toy_text.utils",
        "peekOfCode": "def categorical_sample(prob_n, np_random):\n    \"\"\"\n    Sample from categorical distribution\n    Each row specifies class probabilities\n    \"\"\"\n    prob_n = np.asarray(prob_n)\n    csprob_n = np.cumsum(prob_n)\n    return (csprob_n > np_random.random()).argmax()",
        "detail": "repos_that_could_be_useful.gym.gym.envs.toy_text.utils",
        "documentation": {}
    },
    {
        "label": "EnvSpec",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "class EnvSpec:\n    id: str\n    entry_point: Optional[Union[Callable, str]] = field(default=None)\n    reward_threshold: Optional[float] = field(default=None)\n    nondeterministic: bool = field(default=False)\n    max_episode_steps: Optional[int] = field(default=None)\n    order_enforce: bool = field(default=True)\n    autoreset: bool = field(default=False)\n    kwargs: dict = field(default_factory=dict)\n    namespace: Optional[str] = field(init=False)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def load(name: str) -> Type:\n    mod_name, attr_name = name.split(\":\")\n    mod = importlib.import_module(mod_name)\n    fn = getattr(mod, attr_name)\n    return fn\ndef parse_env_id(id: str) -> Tuple[Optional[str], str, Optional[int]]:\n    \"\"\"Parse environment ID string format.\n    This format is true today, but it's *not* an official spec.\n    [namespace/](env-name)-v(version)    env-name is group 1, version is group 2\n    2016-10-31: We're experimentally expanding the environment ID format",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "parse_env_id",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def parse_env_id(id: str) -> Tuple[Optional[str], str, Optional[int]]:\n    \"\"\"Parse environment ID string format.\n    This format is true today, but it's *not* an official spec.\n    [namespace/](env-name)-v(version)    env-name is group 1, version is group 2\n    2016-10-31: We're experimentally expanding the environment ID format\n    to include an optional namespace.\n    \"\"\"\n    match = ENV_ID_RE.fullmatch(id)\n    if not match:\n        raise error.Error(",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "get_env_id",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def get_env_id(ns: Optional[str], name: str, version: Optional[int]):\n    \"\"\"Get the full env ID given a name and (optional) version and namespace.\n    Inverse of parse_env_id.\"\"\"\n    full_name = name\n    if version is not None:\n        full_name += f\"-v{version}\"\n    if ns is not None:\n        full_name = ns + \"/\" + full_name\n    return full_name\n@dataclass",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "find_highest_version",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def find_highest_version(ns: Optional[str], name: str) -> Optional[int]:\n    version: list[int] = [\n        spec_.version\n        for spec_ in registry.values()\n        if spec_.namespace == ns and spec_.name == name and spec_.version is not None\n    ]\n    return max(version, default=None)\ndef load_env_plugins(entry_point: str = \"gym.envs\") -> None:\n    # Load third-party environments\n    for plugin in metadata.entry_points(group=entry_point):",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "load_env_plugins",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def load_env_plugins(entry_point: str = \"gym.envs\") -> None:\n    # Load third-party environments\n    for plugin in metadata.entry_points(group=entry_point):\n        # Python 3.8 doesn't support plugin.module, plugin.attr\n        # So we'll have to try and parse this ourselves\n        module, attr = None, None\n        try:\n            module, attr = plugin.module, plugin.attr  # type: ignore  ## error: Cannot access member \"attr\" for type \"EntryPoint\"\n        except AttributeError:\n            if \":\" in plugin.value:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"CartPole-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"MountainCar-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"MountainCarContinuous-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Pendulum-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Acrobot-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Box2d",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"MountainCar-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"MountainCarContinuous-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Pendulum-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Acrobot-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Box2d\n# ----------------------------------------\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"MountainCarContinuous-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Pendulum-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Acrobot-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Box2d\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"LunarLander-v2\", \"LunarLanderContinuous-v2\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"Pendulum-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"Acrobot-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Box2d\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"LunarLander-v2\", \"LunarLanderContinuous-v2\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"BipedalWalker-v3\", \"BipedalWalkerHardcore-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"Acrobot-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Box2d\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"LunarLander-v2\", \"LunarLanderContinuous-v2\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"BipedalWalker-v3\", \"BipedalWalkerHardcore-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"CarRacing-v1\", \"CarRacingDomainRandomize-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n# Toy Text",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"LunarLander-v2\", \"LunarLanderContinuous-v2\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"BipedalWalker-v3\", \"BipedalWalkerHardcore-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"CarRacing-v1\", \"CarRacingDomainRandomize-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n# Toy Text\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"Blackjack-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"BipedalWalker-v3\", \"BipedalWalkerHardcore-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n@overload\ndef make(id: Literal[\"CarRacing-v1\", \"CarRacingDomainRandomize-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n# Toy Text\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"Blackjack-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"FrozenLake-v1\", \"FrozenLake8x8-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"CarRacing-v1\", \"CarRacingDomainRandomize-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | Sequence[SupportsFloat]]: ...\n# Toy Text\n# ----------------------------------------\n@overload\ndef make(id: Literal[\"Blackjack-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"FrozenLake-v1\", \"FrozenLake8x8-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"CliffWalking-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"Blackjack-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"FrozenLake-v1\", \"FrozenLake8x8-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"CliffWalking-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"Taxi-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Mujoco\n# ----------------------------------------\n@overload",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"FrozenLake-v1\", \"FrozenLake8x8-v1\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"CliffWalking-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"Taxi-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Mujoco\n# ----------------------------------------\n@overload\ndef make(id: Literal[\n    \"Reacher-v2\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"CliffWalking-v0\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n@overload\ndef make(id: Literal[\"Taxi-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Mujoco\n# ----------------------------------------\n@overload\ndef make(id: Literal[\n    \"Reacher-v2\",\n    \"Pusher-v2\",\n    \"Thrower-v2\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\"Taxi-v3\"], **kwargs) -> Env[np.ndarray, np.ndarray | int]: ...\n# Mujoco\n# ----------------------------------------\n@overload\ndef make(id: Literal[\n    \"Reacher-v2\",\n    \"Pusher-v2\",\n    \"Thrower-v2\",\n    \"Striker-v2\",\n    \"InvertedPendulum-v2\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: Literal[\n    \"Reacher-v2\",\n    \"Pusher-v2\",\n    \"Thrower-v2\",\n    \"Striker-v2\",\n    \"InvertedPendulum-v2\",\n    \"InvertedDoublePendulum-v2\",\n    \"HalfCheetah-v2\", \"HalfCheetah-v3\",\n    \"Hopper-v2\", \"Hopper-v3\",\n    \"Swimmer-v2\", \"Swimmer-v3\",",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: str, **kwargs) -> Env: ...\n@overload\ndef make(id: EnvSpec, **kwargs) -> Env: ...\n# fmt: on\n# Global registry of environments. Meant to be accessed through `register` and `make`\nregistry: dict[str, EnvSpec] = dict()\ncurrent_namespace: Optional[str] = None\ndef _check_spec_register(spec: EnvSpec):\n    \"\"\"Checks whether the spec is valid to be registered. Helper function for `register`.\"\"\"\n    global registry, current_namespace",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(id: EnvSpec, **kwargs) -> Env: ...\n# fmt: on\n# Global registry of environments. Meant to be accessed through `register` and `make`\nregistry: dict[str, EnvSpec] = dict()\ncurrent_namespace: Optional[str] = None\ndef _check_spec_register(spec: EnvSpec):\n    \"\"\"Checks whether the spec is valid to be registered. Helper function for `register`.\"\"\"\n    global registry, current_namespace\n    if current_namespace is not None:\n        if spec.namespace is not None:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "namespace",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def namespace(ns: str):\n    global current_namespace\n    old_namespace = current_namespace\n    current_namespace = ns\n    yield\n    current_namespace = old_namespace\ndef register(id: str, **kwargs):\n    \"\"\"\n    Register an environment with gym. The `id` parameter corresponds to the name of the environment,\n    with the syntax as follows:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def register(id: str, **kwargs):\n    \"\"\"\n    Register an environment with gym. The `id` parameter corresponds to the name of the environment,\n    with the syntax as follows:\n    `(namespace)/(env_name)-v(version)`\n    where `namespace` is optional.\n    It takes arbitrary keyword arguments, which are passed to the `EnvSpec` constructor.\n    \"\"\"\n    global registry, current_namespace\n    ns, name, version = parse_env_id(id)",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def make(\n    id: str | EnvSpec,\n    max_episode_steps: Optional[int] = None,\n    autoreset: bool = False,\n    **kwargs,\n) -> Env:\n    \"\"\"\n    Create an environment according to the given ID.\n    Args:\n        id: Name of the environment.",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "spec",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.envs.registration",
        "description": "repos_that_could_be_useful.gym.gym.envs.registration",
        "peekOfCode": "def spec(env_id: str) -> EnvSpec:\n    \"\"\"\n    Retrieve the spec for the given environment from the global registry.\n    \"\"\"\n    spec_ = registry.get(env_id)\n    if spec_ is None:\n        ns, name, version = parse_env_id(env_id)\n        _check_version_exists(ns, name, version)\n        raise error.Error(f\"No registered env with id: {env_id}\")\n    else:",
        "detail": "repos_that_could_be_useful.gym.gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "Box",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.box",
        "description": "repos_that_could_be_useful.gym.gym.spaces.box",
        "peekOfCode": "class Box(Space[np.ndarray]):\n    r\"\"\"A (possibly unbounded) box in :math:`\\mathbb{R}^n`.\n    Specifically, a Box represents the Cartesian product of n closed intervals.\n    Each interval has the form of one of :math:`[a, b]`, :math:`(-\\infty, b]`,\n    :math:`[a, \\infty)`, or :math:`(-\\infty, \\infty)`.\n    There are two common use cases:\n    * Identical bound for each dimension::\n        >>> Box(low=-1.0, high=2.0, shape=(3, 4), dtype=np.float32)\n        Box(3, 4)\n    * Independent bound for each dimension::",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "get_inf",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.box",
        "description": "repos_that_could_be_useful.gym.gym.spaces.box",
        "peekOfCode": "def get_inf(dtype, sign: str) -> SupportsFloat:\n    \"\"\"Returns an infinite that doesn't break things.\n    Args:\n        dtype: An `np.dtype`\n        sign (str): must be either `\"+\"` or `\"-\"`\n    \"\"\"\n    if np.dtype(dtype).kind == \"f\":\n        if sign == \"+\":\n            return np.inf\n        elif sign == \"-\":",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "get_precision",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.box",
        "description": "repos_that_could_be_useful.gym.gym.spaces.box",
        "peekOfCode": "def get_precision(dtype) -> SupportsFloat:\n    \"\"\"Get precision of a data type.\"\"\"\n    if np.issubdtype(dtype, np.floating):\n        return np.finfo(dtype).precision\n    else:\n        return np.inf\ndef _broadcast(\n    value: Union[SupportsFloat, np.ndarray],\n    dtype,\n    shape: tuple[int, ...],",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.dict",
        "description": "repos_that_could_be_useful.gym.gym.spaces.dict",
        "peekOfCode": "class Dict(Space[TypingDict[str, Space]], Mapping):\n    \"\"\"A dictionary of :class:`Space` instances.\n    Elements of this space are (ordered) dictionaries of elements from the constituent spaces.\n    Example usage::\n        >>> observation_space = spaces.Dict({\"position\": spaces.Discrete(2), \"velocity\": spaces.Discrete(3)})\n        >>> observation_space.sample()\n        OrderedDict([('position', 1), ('velocity', 2)])\n    Example usage [nested]::\n        >>> spaces.Dict(\n        ...     {",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.dict",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.discrete",
        "description": "repos_that_could_be_useful.gym.gym.spaces.discrete",
        "peekOfCode": "class Discrete(Space[int]):\n    r\"\"\"A space consisting of finitely many elements.\n    This class represents a finite subset of integers, more specifically a set of the form :math:`\\{ a, a+1, \\dots, a+n-1 \\}`.\n    Example::\n        >>> Discrete(2)            # {0, 1}\n        >>> Discrete(3, start=-1)  # {-1, 0, 1}\n    \"\"\"\n    def __init__(\n        self,\n        n: int,",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.discrete",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.multi_binary",
        "description": "repos_that_could_be_useful.gym.gym.spaces.multi_binary",
        "peekOfCode": "class MultiBinary(Space[np.ndarray]):\n    \"\"\"An n-shape binary space.\n    Elements of this space are binary arrays of a shape that is fixed during construction.\n    Example Usage::\n        >>> self.observation_space = spaces.MultiBinary(5)\n        >>> self.observation_space.sample()\n            array([0, 1, 0, 1, 0], dtype=int8)\n        >>> self.observation_space = spaces.MultiBinary([3, 2])\n        >>> self.observation_space.sample()\n            array([[0, 0],",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.multi_binary",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.multi_discrete",
        "description": "repos_that_could_be_useful.gym.gym.spaces.multi_discrete",
        "peekOfCode": "class MultiDiscrete(Space[np.ndarray]):\n    \"\"\"This represents the cartesian product of arbitrary :class:`Discrete` spaces.\n    It is useful to represent game controllers or keyboards where each key can be represented as a discrete action space.\n    Note:\n        Some environment wrappers assume a value of 0 always represents the NOOP action.\n    e.g. Nintendo Game Controller - Can be conceptualized as 3 discrete action spaces:\n    1. Arrow Keys: Discrete 5  - NOOP[0], UP[1], RIGHT[2], DOWN[3], LEFT[4]  - params: min: 0, max: 4\n    2. Button A:   Discrete 2  - NOOP[0], Pressed[1] - params: min: 0, max: 1\n    3. Button B:   Discrete 2  - NOOP[0], Pressed[1] - params: min: 0, max: 1\n    It can be initialized as ``MultiDiscrete([ 5, 2, 2 ])``",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.multi_discrete",
        "documentation": {}
    },
    {
        "label": "Space",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.space",
        "description": "repos_that_could_be_useful.gym.gym.spaces.space",
        "peekOfCode": "class Space(Generic[T_cov]):\n    \"\"\"Superclass that is used to define observation and action spaces.\n    Spaces are crucially used in Gym to define the format of valid actions and observations.\n    They serve various purposes:\n    * They clearly define how to interact with environments, i.e. they specify what actions need to look like and what observations will look like\n    * They allow us to work with highly structured data (e.g. in the form of elements of :class:`Dict` spaces) and painlessly transform them into flat arrays that can be used in learning code\n    * They provide a method to sample random elements. This is especially useful for exploration and debugging.\n    Different spaces can be combined hierarchically via container spaces (:class:`Tuple` and :class:`Dict`) to build a\n    more expressive space\n    Warning:",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "T_cov",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.space",
        "description": "repos_that_could_be_useful.gym.gym.spaces.space",
        "peekOfCode": "T_cov = TypeVar(\"T_cov\", covariant=True)\nclass Space(Generic[T_cov]):\n    \"\"\"Superclass that is used to define observation and action spaces.\n    Spaces are crucially used in Gym to define the format of valid actions and observations.\n    They serve various purposes:\n    * They clearly define how to interact with environments, i.e. they specify what actions need to look like and what observations will look like\n    * They allow us to work with highly structured data (e.g. in the form of elements of :class:`Dict` spaces) and painlessly transform them into flat arrays that can be used in learning code\n    * They provide a method to sample random elements. This is especially useful for exploration and debugging.\n    Different spaces can be combined hierarchically via container spaces (:class:`Tuple` and :class:`Dict`) to build a\n    more expressive space",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.space",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.tuple",
        "description": "repos_that_could_be_useful.gym.gym.spaces.tuple",
        "peekOfCode": "class Tuple(Space[tuple], Sequence):\n    \"\"\"A tuple (more precisely: the cartesian product) of :class:`Space` instances.\n    Elements of this space are tuples of elements of the constituent spaces.\n    Example usage::\n        >> observation_space = spaces.Tuple((spaces.Discrete(2), spaces.Box(-1, 1, shape=(2,))))\n        >> observation_space.sample()\n        (0, array([0.03633198, 0.42370757], dtype=float32))\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.tuple",
        "documentation": {}
    },
    {
        "label": "flatdim",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "description": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "peekOfCode": "def flatdim(space: Space) -> int:\n    \"\"\"Return the number of dimensions a flattened equivalent of this space would have.\n    Accepts a space and returns an integer.\n    Raises:\n         NotImplementedError: if the space is not defined in ``gym.spaces``.\n    Example usage::\n        >>> s = spaces.Dict({\"position\": spaces.Discrete(2), \"velocity\": spaces.Discrete(3)})\n        >>> spaces.flatdim(s)\n        5\n    \"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "description": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "peekOfCode": "def flatten(space: Space[T], x: T) -> np.ndarray:\n    \"\"\"Flatten a data point from a space.\n    This is useful when e.g. points from spaces must be passed to a neural\n    network, which only understands flat arrays of floats.\n    Accepts a space and a point from that space. Always returns a 1D array.\n    Raises ``NotImplementedError`` if the space is not defined in\n    ``gym.spaces``.\n    \"\"\"\n    raise NotImplementedError(f\"Unknown space: `{space}`\")\n@flatten.register(Box)",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "documentation": {}
    },
    {
        "label": "unflatten",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "description": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "peekOfCode": "def unflatten(space: Space[T], x: np.ndarray) -> T:\n    \"\"\"Unflatten a data point from a space.\n    This reverses the transformation applied by :func:`flatten`. You must ensure\n    that the ``space`` argument is the same as for the :func:`flatten` call.\n    Accepts a space and a flattened point. Returns a point with a structure\n    that matches the space. Raises ``NotImplementedError`` if the space is not\n    defined in ``gym.spaces``.\n    \"\"\"\n    raise NotImplementedError(f\"Unknown space: `{space}`\")\n@unflatten.register(Box)",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "documentation": {}
    },
    {
        "label": "flatten_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "description": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "peekOfCode": "def flatten_space(space: Space) -> Box:\n    \"\"\"Flatten a space into a single ``Box``.\n    This is equivalent to :func:`flatten`, but operates on the space itself. The\n    result always is a `Box` with flat boundaries. The box has exactly\n    :func:`flatdim` dimensions. Flattening a sample of the original space\n    has the same effect as taking a sample of the flattenend space.\n    Raises ``NotImplementedError`` if the space is not defined in\n    ``gym.spaces``.\n    Example::\n        >>> box = Box(0.0, 1.0, shape=(3, 4, 5))",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "description": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "peekOfCode": "T = TypeVar(\"T\")\n@singledispatch\ndef flatten(space: Space[T], x: T) -> np.ndarray:\n    \"\"\"Flatten a data point from a space.\n    This is useful when e.g. points from spaces must be passed to a neural\n    network, which only understands flat arrays of floats.\n    Accepts a space and a point from that space. Always returns a 1D array.\n    Raises ``NotImplementedError`` if the space is not defined in\n    ``gym.spaces``.\n    \"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.spaces.utils",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "description": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "peekOfCode": "def colorize(string, color, bold=False, highlight=False):\n    \"\"\"Return string surrounded by appropriate terminal color codes to\n    print colorized text.  Valid colors: gray, red, green, yellow,\n    blue, magenta, cyan, white, crimson\n    \"\"\"\n    attr = []\n    num = color2num[color]\n    if highlight:\n        num += 10\n    attr.append(str(num))",
        "detail": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "documentation": {}
    },
    {
        "label": "color2num",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "description": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "peekOfCode": "color2num = dict(\n    gray=30,\n    red=31,\n    green=32,\n    yellow=33,\n    blue=34,\n    magenta=35,\n    cyan=36,\n    white=37,\n    crimson=38,",
        "detail": "repos_that_could_be_useful.gym.gym.utils.colorize",
        "documentation": {}
    },
    {
        "label": "check_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.env_checker",
        "description": "repos_that_could_be_useful.gym.gym.utils.env_checker",
        "peekOfCode": "def check_env(env: gym.Env, warn: bool = True, skip_render_check: bool = True) -> None:\n    \"\"\"\n    Check that an environment follows Gym API.\n    This is particularly useful when using a custom environment.\n    Please take a look at https://github.com/openai/gym/blob/master/gym/core.py\n    for more information about the API.\n    It also optionally check that the environment is compatible with Stable-Baselines.\n    :param env: The Gym environment that will be checked\n    :param warn: Whether to output additional warnings\n        mainly related to the interaction with Stable Baselines",
        "detail": "repos_that_could_be_useful.gym.gym.utils.env_checker",
        "documentation": {}
    },
    {
        "label": "EzPickle",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.ezpickle",
        "description": "repos_that_could_be_useful.gym.gym.utils.ezpickle",
        "peekOfCode": "class EzPickle:\n    \"\"\"Objects that are pickled and unpickled via their constructor\n    arguments.\n    Example usage:\n        class Dog(Animal, EzPickle):\n            def __init__(self, furcolor, tailkind=\"bushy\"):\n                Animal.__init__()\n                EzPickle.__init__(furcolor, tailkind)\n                ...\n    When this object is unpickled, a new Dog will be constructed by passing the provided",
        "detail": "repos_that_could_be_useful.gym.gym.utils.ezpickle",
        "documentation": {}
    },
    {
        "label": "MissingKeysToAction",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.play",
        "description": "repos_that_could_be_useful.gym.gym.utils.play",
        "peekOfCode": "class MissingKeysToAction(Exception):\n    \"\"\"Raised when the environment does not have\n    a default keys_to_action mapping\n    \"\"\"\nclass PlayableGame:\n    def __init__(\n        self,\n        env: Env,\n        keys_to_action: Optional[Dict[Tuple[int], int]] = None,\n        zoom: Optional[float] = None,",
        "detail": "repos_that_could_be_useful.gym.gym.utils.play",
        "documentation": {}
    },
    {
        "label": "PlayableGame",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.play",
        "description": "repos_that_could_be_useful.gym.gym.utils.play",
        "peekOfCode": "class PlayableGame:\n    def __init__(\n        self,\n        env: Env,\n        keys_to_action: Optional[Dict[Tuple[int], int]] = None,\n        zoom: Optional[float] = None,\n    ):\n        self.env = env\n        self.relevant_keys = self._get_relevant_keys(keys_to_action)\n        self.video_size = self._get_video_size(zoom)",
        "detail": "repos_that_could_be_useful.gym.gym.utils.play",
        "documentation": {}
    },
    {
        "label": "PlayPlot",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.play",
        "description": "repos_that_could_be_useful.gym.gym.utils.play",
        "peekOfCode": "class PlayPlot:\n    def __init__(self, callback, horizon_timesteps, plot_names):\n        deprecation(\n            \"`PlayPlot` is marked as deprecated and will be removed in the near future.\"\n        )\n        self.data_callback = callback\n        self.horizon_timesteps = horizon_timesteps\n        self.plot_names = plot_names\n        assert plt is not None, \"matplotlib backend failed, plotting will not work\"\n        num_plots = len(self.plot_names)",
        "detail": "repos_that_could_be_useful.gym.gym.utils.play",
        "documentation": {}
    },
    {
        "label": "display_arr",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.play",
        "description": "repos_that_could_be_useful.gym.gym.utils.play",
        "peekOfCode": "def display_arr(\n    screen: Surface, arr: NDArray, video_size: Tuple[int, int], transpose: bool\n):\n    arr_min, arr_max = arr.min(), arr.max()\n    arr = 255.0 * (arr - arr_min) / (arr_max - arr_min)\n    pyg_img = pygame.surfarray.make_surface(arr.swapaxes(0, 1) if transpose else arr)\n    pyg_img = pygame.transform.scale(pyg_img, video_size)\n    screen.blit(pyg_img, (0, 0))\ndef play(\n    env: Env,",
        "detail": "repos_that_could_be_useful.gym.gym.utils.play",
        "documentation": {}
    },
    {
        "label": "play",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.play",
        "description": "repos_that_could_be_useful.gym.gym.utils.play",
        "peekOfCode": "def play(\n    env: Env,\n    transpose: Optional[bool] = True,\n    fps: Optional[int] = 30,\n    zoom: Optional[float] = None,\n    callback: Optional[Callable] = None,\n    keys_to_action: Optional[Dict[Tuple[int], int]] = None,\n    seed: Optional[int] = None,\n):\n    \"\"\"Allows one to play the game using keyboard.",
        "detail": "repos_that_could_be_useful.gym.gym.utils.play",
        "documentation": {}
    },
    {
        "label": "RandomNumberGenerator",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "description": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "peekOfCode": "class RandomNumberGenerator(np.random.Generator):\n    def rand(self, *size):\n        deprecation(\n            \"Function `rng.rand(*size)` is marked as deprecated \"\n            \"and will be removed in the future. \"\n            \"Please use `Generator.random(size)` instead.\"\n        )\n        return self.random(size)\n    random_sample = rand\n    def randn(self, *size):",
        "detail": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "np_random",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "description": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "peekOfCode": "def np_random(seed: Optional[int] = None) -> Tuple[\"RandomNumberGenerator\", Any]:\n    if seed is not None and not (isinstance(seed, int) and 0 <= seed):\n        raise error.Error(f\"Seed must be a non-negative integer or omitted, not {seed}\")\n    seed_seq = np.random.SeedSequence(seed)\n    np_seed = seed_seq.entropy\n    rng = RandomNumberGenerator(np.random.PCG64(seed_seq))\n    return rng, np_seed\n# TODO: Remove this class and make it alias to `Generator` in a future Gym release\n# RandomNumberGenerator = np.random.Generator\nclass RandomNumberGenerator(np.random.Generator):",
        "detail": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "hash_seed",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "description": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "peekOfCode": "def hash_seed(seed: Optional[int] = None, max_bytes: int = 8) -> int:\n    \"\"\"Any given evaluation is likely to have many PRNG's active at\n    once. (Most commonly, because the environment is running in\n    multiple processes.) There's literature indicating that having\n    linear correlations between seeds of multiple PRNG's can correlate\n    the outputs:\n    http://blogs.unity3d.com/2015/01/07/a-primer-on-repeatable-random-numbers/\n    http://stackoverflow.com/questions/1554958/how-different-do-random-seeds-need-to-be\n    http://dl.acm.org/citation.cfm?id=1276928\n    Thus, for sanity we hash the seeds before using them. (This scheme",
        "detail": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "create_seed",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "description": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "peekOfCode": "def create_seed(a: Optional[Union[int, str]] = None, max_bytes: int = 8) -> int:\n    \"\"\"Create a strong random seed. Otherwise, Python 2 would seed using\n    the system time, which might be non-robust especially in the\n    presence of concurrency.\n    Args:\n        a: None seeds from an operating system specific randomness source.\n        max_bytes: Maximum number of bytes to use in the seed.\n    \"\"\"\n    deprecation(\n        \"Function `create_seed(a, max_bytes)` is marked as deprecated and will be removed in the future. \"",
        "detail": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "RNG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "description": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "peekOfCode": "RNG = RandomNumberGenerator\n# Legacy functions\ndef hash_seed(seed: Optional[int] = None, max_bytes: int = 8) -> int:\n    \"\"\"Any given evaluation is likely to have many PRNG's active at\n    once. (Most commonly, because the environment is running in\n    multiple processes.) There's literature indicating that having\n    linear correlations between seeds of multiple PRNG's can correlate\n    the outputs:\n    http://blogs.unity3d.com/2015/01/07/a-primer-on-repeatable-random-numbers/\n    http://stackoverflow.com/questions/1554958/how-different-do-random-seeds-need-to-be",
        "detail": "repos_that_could_be_useful.gym.gym.utils.seeding",
        "documentation": {}
    },
    {
        "label": "CloudpickleWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "peekOfCode": "class CloudpickleWrapper:\n    def __init__(self, fn):\n        self.fn = fn\n    def __getstate__(self):\n        import cloudpickle\n        return cloudpickle.dumps(self.fn)\n    def __setstate__(self, ob):\n        import pickle\n        self.fn = pickle.loads(ob)\n    def __call__(self):",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "documentation": {}
    },
    {
        "label": "clear_mpi_env_vars",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "peekOfCode": "def clear_mpi_env_vars():\n    \"\"\"\n    `from mpi4py import MPI` will call `MPI_Init` by default. If the child\n    process has MPI environment variables, MPI will think that the child process\n    is an MPI process just like the parent and do bad things such as hang.\n    This context manager is a hacky way to clear those environment variables\n    temporarily such as when we are starting multiprocessing Processes.\n    \"\"\"\n    removed_environment = {}\n    for k, v in list(os.environ.items()):",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "peekOfCode": "__all__ = [\"CloudpickleWrapper\", \"clear_mpi_env_vars\"]\nclass CloudpickleWrapper:\n    def __init__(self, fn):\n        self.fn = fn\n    def __getstate__(self):\n        import cloudpickle\n        return cloudpickle.dumps(self.fn)\n    def __setstate__(self, ob):\n        import pickle\n        self.fn = pickle.loads(ob)",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.misc",
        "documentation": {}
    },
    {
        "label": "concatenate",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "peekOfCode": "def concatenate(space, items, out):\n    \"\"\"Concatenate multiple samples from space into a single object.\n    Parameters\n    ----------\n    items : iterable of samples of `space`\n        Samples to be concatenated.\n    out : tuple, dict, or `np.ndarray`\n        The output object. This object is a (possibly nested) numpy array.\n    space : `gym.spaces.Space` instance\n        Observation space of a single environment in the vectorized environment.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "documentation": {}
    },
    {
        "label": "create_empty_array",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "peekOfCode": "def create_empty_array(space, n=1, fn=np.zeros):\n    \"\"\"Create an empty (possibly nested) numpy array.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Observation space of a single environment in the vectorized environment.\n    n : int\n        Number of environments in the vectorized environment. If `None`, creates\n        an empty sample from `space`.\n    fn : callable",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "peekOfCode": "__all__ = [\"concatenate\", \"create_empty_array\"]\n@singledispatch\ndef concatenate(space, items, out):\n    \"\"\"Concatenate multiple samples from space into a single object.\n    Parameters\n    ----------\n    items : iterable of samples of `space`\n        Samples to be concatenated.\n    out : tuple, dict, or `np.ndarray`\n        The output object. This object is a (possibly nested) numpy array.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.numpy_utils",
        "documentation": {}
    },
    {
        "label": "create_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "peekOfCode": "def create_shared_memory(space, n=1, ctx=mp):\n    \"\"\"Create a shared memory object, to be shared across processes. This\n    eventually contains the observations from the vectorized environment.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Observation space of a single environment in the vectorized environment.\n    n : int\n        Number of environments in the vectorized environment (i.e. the number\n        of processes).",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "read_from_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "peekOfCode": "def read_from_shared_memory(space, shared_memory, n=1):\n    \"\"\"Read the batch of observations from shared memory as a numpy array.\n    Parameters\n    ----------\n    shared_memory : dict, tuple, or `multiprocessing.Array` instance\n        Shared object across processes. This contains the observations from the\n        vectorized environment. This object is created with `create_shared_memory`.\n    space : `gym.spaces.Space` instance\n        Observation space of a single environment in the vectorized environment.\n    n : int",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "write_to_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "peekOfCode": "def write_to_shared_memory(space, index, value, shared_memory):\n    \"\"\"Write the observation of a single environment into shared memory.\n    Parameters\n    ----------\n    index : int\n        Index of the environment (must be in `[0, num_envs)`).\n    value : sample from `space`\n        Observation of the single environment to write to shared memory.\n    shared_memory : dict, tuple, or `multiprocessing.Array` instance\n        Shared object across processes. This contains the observations from the",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "peekOfCode": "__all__ = [\"create_shared_memory\", \"read_from_shared_memory\", \"write_to_shared_memory\"]\n@singledispatch\ndef create_shared_memory(space, n=1, ctx=mp):\n    \"\"\"Create a shared memory object, to be shared across processes. This\n    eventually contains the observations from the vectorized environment.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Observation space of a single environment in the vectorized environment.\n    n : int",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.shared_memory",
        "documentation": {}
    },
    {
        "label": "batch_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "peekOfCode": "def batch_space(space, n=1):\n    \"\"\"Create a (batched) space, containing multiple copies of a single space.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Space (e.g. the observation space) for a single environment in the\n        vectorized environment.\n    n : int\n        Number of environments in the vectorized environment.\n    Returns",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "peekOfCode": "def iterate(space, items):\n    \"\"\"Iterate over the elements of a (batched) space.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Space to which `items` belong to.\n    items : samples of `space`\n        Items to be iterated over.\n    Returns\n    -------",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "_BaseGymSpaces",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "peekOfCode": "_BaseGymSpaces = (Box, Discrete, MultiDiscrete, MultiBinary)\n__all__ = [\"_BaseGymSpaces\", \"batch_space\", \"iterate\"]\n@singledispatch\ndef batch_space(space, n=1):\n    \"\"\"Create a (batched) space, containing multiple copies of a single space.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Space (e.g. the observation space) for a single environment in the\n        vectorized environment.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "description": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "peekOfCode": "__all__ = [\"_BaseGymSpaces\", \"batch_space\", \"iterate\"]\n@singledispatch\ndef batch_space(space, n=1):\n    \"\"\"Create a (batched) space, containing multiple copies of a single space.\n    Parameters\n    ----------\n    space : `gym.spaces.Space` instance\n        Space (e.g. the observation space) for a single environment in the\n        vectorized environment.\n    n : int",
        "detail": "repos_that_could_be_useful.gym.gym.vector.utils.spaces",
        "documentation": {}
    },
    {
        "label": "AsyncState",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "peekOfCode": "class AsyncState(Enum):\n    DEFAULT = \"default\"\n    WAITING_RESET = \"reset\"\n    WAITING_STEP = \"step\"\n    WAITING_CALL = \"call\"\nclass AsyncVectorEnv(VectorEnv):\n    \"\"\"Vectorized environment that runs multiple environments in parallel. It\n    uses `multiprocessing`_ processes, and pipes for communication.\n    Parameters\n    ----------",
        "detail": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "documentation": {}
    },
    {
        "label": "AsyncVectorEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "peekOfCode": "class AsyncVectorEnv(VectorEnv):\n    \"\"\"Vectorized environment that runs multiple environments in parallel. It\n    uses `multiprocessing`_ processes, and pipes for communication.\n    Parameters\n    ----------\n    env_fns : iterable of callable\n        Functions that create the environments.\n    observation_space : :class:`gym.spaces.Space`, optional\n        Observation space of a single environment. If ``None``, then the\n        observation space of the first environment is taken.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "peekOfCode": "__all__ = [\"AsyncVectorEnv\"]\nclass AsyncState(Enum):\n    DEFAULT = \"default\"\n    WAITING_RESET = \"reset\"\n    WAITING_STEP = \"step\"\n    WAITING_CALL = \"call\"\nclass AsyncVectorEnv(VectorEnv):\n    \"\"\"Vectorized environment that runs multiple environments in parallel. It\n    uses `multiprocessing`_ processes, and pipes for communication.\n    Parameters",
        "detail": "repos_that_could_be_useful.gym.gym.vector.async_vector_env",
        "documentation": {}
    },
    {
        "label": "SyncVectorEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "peekOfCode": "class SyncVectorEnv(VectorEnv):\n    \"\"\"Vectorized environment that serially runs multiple environments.\n    Parameters\n    ----------\n    env_fns : iterable of callable\n        Functions that create the environments.\n    observation_space : :class:`gym.spaces.Space`, optional\n        Observation space of a single environment. If ``None``, then the\n        observation space of the first environment is taken.\n    action_space : :class:`gym.spaces.Space`, optional",
        "detail": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "peekOfCode": "__all__ = [\"SyncVectorEnv\"]\nclass SyncVectorEnv(VectorEnv):\n    \"\"\"Vectorized environment that serially runs multiple environments.\n    Parameters\n    ----------\n    env_fns : iterable of callable\n        Functions that create the environments.\n    observation_space : :class:`gym.spaces.Space`, optional\n        Observation space of a single environment. If ``None``, then the\n        observation space of the first environment is taken.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.sync_vector_env",
        "documentation": {}
    },
    {
        "label": "VectorEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "peekOfCode": "class VectorEnv(gym.Env):\n    r\"\"\"Base class for vectorized environments. Runs multiple independent copies of the\n    same environment in parallel. This is not the same as 1 environment that has multiple\n    sub components, but it is many copies of the same base env.\n    Each observation returned from vectorized environment is a batch of observations\n    for each parallel environment. And :meth:`step` is also expected to receive a batch of\n    actions for each parallel environment.\n    .. note::\n        All parallel environments should share the identical observation and action spaces.\n        In other words, a vector of multiple different environments is not supported.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "VectorEnvWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "peekOfCode": "class VectorEnvWrapper(VectorEnv):\n    r\"\"\"Wraps the vectorized environment to allow a modular transformation.\n    This class is the base class for all wrappers for vectorized environments. The subclass\n    could override some methods to change the behavior of the original vectorized environment\n    without touching the original code.\n    .. note::\n        Don't forget to call ``super().__init__(env)`` if the subclass overrides :meth:`__init__`.\n    \"\"\"\n    def __init__(self, env):\n        assert isinstance(env, VectorEnv)",
        "detail": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "description": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "peekOfCode": "__all__ = [\"VectorEnv\"]\nclass VectorEnv(gym.Env):\n    r\"\"\"Base class for vectorized environments. Runs multiple independent copies of the\n    same environment in parallel. This is not the same as 1 environment that has multiple\n    sub components, but it is many copies of the same base env.\n    Each observation returned from vectorized environment is a batch of observations\n    for each parallel environment. And :meth:`step` is also expected to receive a batch of\n    actions for each parallel environment.\n    .. note::\n        All parallel environments should share the identical observation and action spaces.",
        "detail": "repos_that_could_be_useful.gym.gym.vector.vector_env",
        "documentation": {}
    },
    {
        "label": "VideoRecorder",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "peekOfCode": "class VideoRecorder:\n    \"\"\"VideoRecorder renders a nice movie of a rollout, frame by frame. It\n    comes with an `enabled` option so you can still use the same code\n    on episodes where you don't want to record video.\n    Note:\n        You are responsible for calling `close` on a created\n        VideoRecorder, or else you may leak an encoder process.\n    Args:\n        env (Env): Environment to take video of.\n        path (Optional[str]): Path to the video file; will be randomly chosen if omitted.",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "documentation": {}
    },
    {
        "label": "TextEncoder",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "peekOfCode": "class TextEncoder:\n    \"\"\"Store a moving picture made out of ANSI frames. Format adapted from\n    https://github.com/asciinema/asciinema/blob/master/doc/asciicast-v1.md\"\"\"\n    def __init__(self, output_path, frames_per_sec):\n        self.output_path = output_path\n        self.frames_per_sec = frames_per_sec\n        self.frames = []\n    def capture_frame(self, frame):\n        string = None\n        if isinstance(frame, str):",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "documentation": {}
    },
    {
        "label": "ImageEncoder",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "peekOfCode": "class ImageEncoder:\n    def __init__(self, output_path, frame_shape, frames_per_sec, output_frames_per_sec):\n        self.proc = None\n        self.output_path = output_path\n        # Frame shape should be lines-first, so w and h are swapped\n        h, w, pixfmt = frame_shape\n        if pixfmt != 3 and pixfmt != 4:\n            raise error.InvalidFrame(\n                \"Your frame has shape {}, but we require (w,h,3) or (w,h,4), i.e., RGB values for a w-by-h image, with an optional alpha channel.\".format(\n                    frame_shape",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "documentation": {}
    },
    {
        "label": "touch",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "peekOfCode": "def touch(path):\n    open(path, \"a\").close()\nclass VideoRecorder:\n    \"\"\"VideoRecorder renders a nice movie of a rollout, frame by frame. It\n    comes with an `enabled` option so you can still use the same code\n    on episodes where you don't want to record video.\n    Note:\n        You are responsible for calling `close` on a created\n        VideoRecorder, or else you may leak an encoder process.\n    Args:",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.monitoring.video_recorder",
        "documentation": {}
    },
    {
        "label": "AtariPreprocessing",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.atari_preprocessing",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.atari_preprocessing",
        "peekOfCode": "class AtariPreprocessing(gym.Wrapper):\n    r\"\"\"Atari 2600 preprocessings.\n    This class follows the guidelines in\n    Machado et al. (2018), \"Revisiting the Arcade Learning Environment:\n    Evaluation Protocols and Open Problems for General Agents\".\n    Specifically:\n    * NoopReset: obtain initial state by taking random number of no-ops on reset.\n    * Frame skipping: 4 by default\n    * Max-pooling: most recent two observations\n    * Termination signal when a life is lost: turned off by default. Not recommended by Machado et al. (2018).",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.atari_preprocessing",
        "documentation": {}
    },
    {
        "label": "AutoResetWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.autoreset",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.autoreset",
        "peekOfCode": "class AutoResetWrapper(gym.Wrapper):\n    \"\"\"\n    A class for providing an automatic reset functionality\n    for gym environments when calling self.step().\n    When calling step causes self.env.step() to return done,\n    self.env.reset() is called,\n    and the return format of self.step() is as follows:\n    new_obs, terminal_reward, terminal_done, info\n    new_obs is the first observation after calling self.env.reset(),\n    terminal_reward is the reward after calling self.env.step(),",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.autoreset",
        "documentation": {}
    },
    {
        "label": "ClipAction",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.clip_action",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.clip_action",
        "peekOfCode": "class ClipAction(ActionWrapper):\n    r\"\"\"Clip the continuous action within the valid bound.\"\"\"\n    def __init__(self, env):\n        assert isinstance(env.action_space, Box)\n        super().__init__(env)\n    def action(self, action):\n        return np.clip(action, self.action_space.low, self.action_space.high)",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.clip_action",
        "documentation": {}
    },
    {
        "label": "FilterObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.filter_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.filter_observation",
        "peekOfCode": "class FilterObservation(ObservationWrapper):\n    \"\"\"Filter dictionary observations by their keys.\n    Args:\n        env: The environment to wrap.\n        filter_keys: List of keys to be included in the observations.\n    Raises:\n        ValueError: If observation keys in not instance of None or\n            iterable.\n        ValueError: If any of the `filter_keys` are not included in\n            the original `env`'s observation space",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.filter_observation",
        "documentation": {}
    },
    {
        "label": "FlattenObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.flatten_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.flatten_observation",
        "peekOfCode": "class FlattenObservation(ObservationWrapper):\n    r\"\"\"Observation wrapper that flattens the observation.\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self.observation_space = spaces.flatten_space(env.observation_space)\n    def observation(self, observation):\n        return spaces.flatten(self.env.observation_space, observation)",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.flatten_observation",
        "documentation": {}
    },
    {
        "label": "LazyFrames",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "peekOfCode": "class LazyFrames:\n    r\"\"\"Ensures common frames are only stored once to optimize memory use.\n    To further reduce the memory use, it is optionally to turn on lz4 to\n    compress the observations.\n    .. note::\n        This object should only be converted to numpy array just before forward pass.\n    Args:\n        lz4_compress (bool): use lz4 to compress the frames internally\n    \"\"\"\n    __slots__ = (\"frame_shape\", \"dtype\", \"shape\", \"lz4_compress\", \"_frames\")",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "documentation": {}
    },
    {
        "label": "FrameStack",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "peekOfCode": "class FrameStack(ObservationWrapper):\n    r\"\"\"Observation wrapper that stacks the observations in a rolling manner.\n    For example, if the number of stacks is 4, then the returned observation contains\n    the most recent 4 observations. For environment 'Pendulum-v1', the original observation\n    is an array with shape [3], so if we stack 4 observations, the processed observation\n    has shape [4, 3].\n    .. note::\n        To be memory efficient, the stacked observations are wrapped by :class:`LazyFrame`.\n    .. note::\n        The observation space must be `Box` type. If one uses `Dict`",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.frame_stack",
        "documentation": {}
    },
    {
        "label": "GrayScaleObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.gray_scale_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.gray_scale_observation",
        "peekOfCode": "class GrayScaleObservation(ObservationWrapper):\n    \"\"\"Convert the image observation from RGB to gray scale.\n    Args:\n        keep_dim (bool): If `True`, a singleton dimension will be added, i.e. observations are of the shape AxBx1. Otherwise they are of shape AxB\n    \"\"\"\n    def __init__(self, env, keep_dim: bool = False):\n        super().__init__(env)\n        self.keep_dim = keep_dim\n        assert (\n            len(env.observation_space.shape) == 3",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.gray_scale_observation",
        "documentation": {}
    },
    {
        "label": "RunningMeanStd",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "peekOfCode": "class RunningMeanStd:\n    # https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n    def __init__(self, epsilon=1e-4, shape=()):\n        self.mean = np.zeros(shape, \"float64\")\n        self.var = np.ones(shape, \"float64\")\n        self.count = epsilon\n    def update(self, x):\n        batch_mean = np.mean(x, axis=0)\n        batch_var = np.var(x, axis=0)\n        batch_count = x.shape[0]",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "NormalizeObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "peekOfCode": "class NormalizeObservation(gym.core.Wrapper):\n    \"\"\"This wrapper will normalize observations s.t. each coordinate is centered with unit variance.\n    .. note ::\n        The normalization depends on past trajectories and observations will not be normalized correctly if the wrapper was\n        newly instantiated or the policy was changed recently.\n    Args:\n         epsilon: A stability parameter that is used when scaling the observations.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "NormalizeReward",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "peekOfCode": "class NormalizeReward(gym.core.Wrapper):\n    \"\"\"This wrapper will normalize immediate rewards s.t. their exponential moving average has a fixed variance.\n    The exponential moving average will have variance (1 - `gamma`)**2.\n    .. note ::\n        The scaling depends on past trajectories and rewards will not be scaled correctly if the wrapper was newly\n        instantiated or the policy was changed recently.\n    Args:\n        epsilon (float): A stability parameter\n        gamma (float): The discount factor that is used in the exponential moving average.\n    \"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "update_mean_var_count_from_moments",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "peekOfCode": "def update_mean_var_count_from_moments(\n    mean, var, count, batch_mean, batch_var, batch_count\n):\n    delta = batch_mean - mean\n    tot_count = count + batch_count\n    new_mean = mean + delta * batch_count / tot_count\n    m_a = var * count\n    m_b = batch_var * batch_count\n    M2 = m_a + m_b + np.square(delta) * count * batch_count / tot_count\n    new_var = M2 / tot_count",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.normalize",
        "documentation": {}
    },
    {
        "label": "OrderEnforcing",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.order_enforcing",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.order_enforcing",
        "peekOfCode": "class OrderEnforcing(gym.Wrapper):\n    \"\"\"This will produce an error if `step` is called before an initial `reset`\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self._has_reset = False\n    def step(self, action):\n        assert self._has_reset, \"Cannot call env.step() before calling reset()\"\n        observation, reward, done, info = self.env.step(action)\n        return observation, reward, done, info\n    def reset(self, **kwargs):",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.order_enforcing",
        "documentation": {}
    },
    {
        "label": "PixelObservationWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "peekOfCode": "class PixelObservationWrapper(ObservationWrapper):\n    \"\"\"Augment observations by pixel values.\"\"\"\n    def __init__(\n        self, env, pixels_only=True, render_kwargs=None, pixel_keys=(\"pixels\",)\n    ):\n        \"\"\"Initializes a new pixel Wrapper.\n        Args:\n            env: The environment to wrap.\n            pixels_only: If `True` (default), the original observation returned\n                by the wrapped environment will be discarded, and a dictionary",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "documentation": {}
    },
    {
        "label": "STATE_KEY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "peekOfCode": "STATE_KEY = \"state\"\nclass PixelObservationWrapper(ObservationWrapper):\n    \"\"\"Augment observations by pixel values.\"\"\"\n    def __init__(\n        self, env, pixels_only=True, render_kwargs=None, pixel_keys=(\"pixels\",)\n    ):\n        \"\"\"Initializes a new pixel Wrapper.\n        Args:\n            env: The environment to wrap.\n            pixels_only: If `True` (default), the original observation returned",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.pixel_observation",
        "documentation": {}
    },
    {
        "label": "RecordEpisodeStatistics",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.record_episode_statistics",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.record_episode_statistics",
        "peekOfCode": "class RecordEpisodeStatistics(gym.Wrapper):\n    \"\"\"This wrapper will keep track of cumulative rewards and episode lengths.\n    At the end of an episode, the statistics of the episode will be added to `info`. After the completion\n    of an episode, `info` will look like this:\n    ```\n    info = {\n        ...\n        \"episode\": {\n            \"r\": <cumulative reward>,\n            \"l\": <episode length>,",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.record_episode_statistics",
        "documentation": {}
    },
    {
        "label": "RecordVideo",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "peekOfCode": "class RecordVideo(gym.Wrapper):\n    \"\"\"This wrapper records videos of rollouts.\n    Usually, you only want to record episodes intermittently, say every hundreth episode.\n    To do this, you can specify **either** `episode_trigger` **or** `step_trigger` (not both).\n    They should be functions returning a boolean that indicates whether a recording should be started at the\n    current episode or step, respectively.\n    If neither `episode_trigger` nor `step_trigger` is passed, a default `episode_trigger` will be employed.\n    By default, the recording will be stopped once a `done` signal has been emitted by the environment. However, you can\n    also create recordings of fixed length (possibly spanning several episodes) by passing a strictly positive value for\n    `video_length`.",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "documentation": {}
    },
    {
        "label": "capped_cubic_video_schedule",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "peekOfCode": "def capped_cubic_video_schedule(episode_id):\n    if episode_id < 1000:\n        return int(round(episode_id ** (1.0 / 3))) ** 3 == episode_id\n    else:\n        return episode_id % 1000 == 0\nclass RecordVideo(gym.Wrapper):\n    \"\"\"This wrapper records videos of rollouts.\n    Usually, you only want to record episodes intermittently, say every hundreth episode.\n    To do this, you can specify **either** `episode_trigger` **or** `step_trigger` (not both).\n    They should be functions returning a boolean that indicates whether a recording should be started at the",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.record_video",
        "documentation": {}
    },
    {
        "label": "RescaleAction",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.rescale_action",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.rescale_action",
        "peekOfCode": "class RescaleAction(gym.ActionWrapper):\n    r\"\"\"Rescales the continuous action space of the environment to a range [min_action, max_action].\n    The wrapped environment `env` must have an action space of type `spaces.Box`. If `min_action`\n    or `max_action` are numpy arrays, the shape must match the shape of the environment's action space.\n    Example::\n        >>> RescaleAction(env, min_action, max_action).action_space == Box(min_action, max_action)\n        True\n    Args:\n        env: The environment that will be wrapped\n        min_action (Union[np.array, float]): The lower bound of the new action space. This may be a numpy array or a scalar.",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.rescale_action",
        "documentation": {}
    },
    {
        "label": "ResizeObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.resize_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.resize_observation",
        "peekOfCode": "class ResizeObservation(ObservationWrapper):\n    \"\"\"Resize the image observation.\n    This wrapper works on environments with image observations (or more generally observations of shape AxBxC) and resizes\n    the observation to the shape given by the 2-tuple `shape`. The argument `shape` may also be an integer. In that case, the\n    observation is scaled to a square of side-length `shape`.\n    Args:\n        shape (Union[tuple, int]): The dimensions of the resized observation\n    \"\"\"\n    def __init__(self, env, shape: Union[tuple, int]):\n        super().__init__(env)",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.resize_observation",
        "documentation": {}
    },
    {
        "label": "TimeAwareObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.time_aware_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.time_aware_observation",
        "peekOfCode": "class TimeAwareObservation(ObservationWrapper):\n    r\"\"\"Augment the observation with current time step in the trajectory.\n    .. note::\n        Currently it only works with one-dimensional observation space. It doesn't\n        support pixel observation space yet.\n    \"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        assert isinstance(env.observation_space, Box)\n        assert env.observation_space.dtype == np.float32",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.time_aware_observation",
        "documentation": {}
    },
    {
        "label": "TimeLimit",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.time_limit",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.time_limit",
        "peekOfCode": "class TimeLimit(gym.Wrapper):\n    \"\"\"This wrapper will issue a `done` signal if a maximum number of timesteps is exceeded.\n    Oftentimes, it is **very** important to distinguish `done` signals that were produced by the\n    `TimeLimit` wrapper (truncations) and those that originate from the underlying environment (terminations).\n    This can be done by looking at the `info` that is returned when `done` signal was issued.\n    The done-signal originates from the time limit (i.e. it signifies a *truncation*) if and only if\n    the key `\"TimeLimit.truncated\"` exists in `info` and the corresponding value is `True`.\n    Args:\n        env: The environment that will be wrapped\n        max_episode_steps (Optional[int]): The maximum number of steps until a done-signal occurs. If it is `None`, the value from `env.spec` (if available) will be used",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.time_limit",
        "documentation": {}
    },
    {
        "label": "TransformObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.transform_observation",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.transform_observation",
        "peekOfCode": "class TransformObservation(ObservationWrapper):\n    r\"\"\"Transform the observation via an arbitrary function.\n    Example::\n        >>> import gym\n        >>> env = gym.make('CartPole-v1')\n        >>> env = TransformObservation(env, lambda obs: obs + 0.1*np.random.randn(*obs.shape))\n        >>> env.reset()\n        array([-0.08319338,  0.04635121, -0.07394746,  0.20877492])\n    Args:\n        env (Env): environment",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.transform_observation",
        "documentation": {}
    },
    {
        "label": "TransformReward",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.wrappers.transform_reward",
        "description": "repos_that_could_be_useful.gym.gym.wrappers.transform_reward",
        "peekOfCode": "class TransformReward(RewardWrapper):\n    r\"\"\"Transform the reward via an arbitrary function.\n    Example::\n        >>> import gym\n        >>> env = gym.make('CartPole-v1')\n        >>> env = TransformReward(env, lambda r: 0.01*r)\n        >>> env.reset()\n        >>> observation, reward, done, info = env.step(env.action_space.sample())\n        >>> reward\n        0.01",
        "detail": "repos_that_could_be_useful.gym.gym.wrappers.transform_reward",
        "documentation": {}
    },
    {
        "label": "Env",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "class Env(Generic[ObsType, ActType]):\n    r\"\"\"The main OpenAI Gym class.\n    It encapsulates an environment with arbitrary behind-the-scenes dynamics.\n    An environment can be partially or fully observed.\n    The main API methods that users of this class need to know are:\n    - :meth:`step` - Takes a step in the environment using an action returning the next observation, reward,\n      if the environment terminated and more information.\n    - :meth:`reset` - Resets the environment to an initial state, returning the initial observation.\n    - :meth:`render` - Renders the environment observation with modes depending on the output\n    - :meth:`close` - Closes the environment, important for rendering where pygame is imported",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "class Wrapper(Env[ObsType, ActType]):\n    \"\"\"Wraps an environment to allow a modular transformation of the :meth:`step` and :meth:`reset` methods.\n    This class is the base class for all wrappers. The subclass could override\n    some methods to change the behavior of the original environment without touching the\n    original code.\n    Note:\n        Don't forget to call ``super().__init__(env)`` if the subclass overrides :meth:`__init__`.\n    \"\"\"\n    def __init__(self, env: Env):\n        \"\"\"Wraps an environment to allow a modular transformation of the :meth:`step` and :meth:`reset` methods.",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "class ObservationWrapper(Wrapper):\n    \"\"\"A wrapper that can modify observations using :meth:`observation` for :meth:`reset` and :meth:`step`.\"\"\"\n    def reset(self, **kwargs):\n        \"\"\"Resets the environment, returning a modified observation using :meth:`self.observation`.\"\"\"\n        if kwargs.get(\"return_info\", False):\n            obs, info = self.env.reset(**kwargs)\n            return self.observation(obs), info\n        else:\n            return self.observation(self.env.reset(**kwargs))\n    def step(self, action):",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "RewardWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "class RewardWrapper(Wrapper):\n    \"\"\"A wrapper that can modify the returning reward from a step.\"\"\"\n    def step(self, action):\n        \"\"\"Modifies the reward using :meth:`self.reward` after the environment :meth:`env.step`.\"\"\"\n        observation, reward, done, info = self.env.step(action)\n        return observation, self.reward(reward), done, info\n    @abstractmethod\n    def reward(self, reward):\n        \"\"\"Returns a modified ``reward``.\"\"\"\n        raise NotImplementedError",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "ActionWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "class ActionWrapper(Wrapper):\n    \"\"\"A wrapper that can modify the action before :meth:`env.step`.\"\"\"\n    def step(self, action):\n        \"\"\"Runs the environment :meth:`env.step` using the modified ``action`` from :meth:`self.action`.\"\"\"\n        return self.env.step(self.action(action))\n    @abstractmethod\n    def action(self, action):\n        \"\"\"Returns a modified action before :meth:`env.step` is called.\"\"\"\n        raise NotImplementedError\n    @abstractmethod",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "ObsType",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "ObsType = TypeVar(\"ObsType\")\nActType = TypeVar(\"ActType\")\nclass Env(Generic[ObsType, ActType]):\n    r\"\"\"The main OpenAI Gym class.\n    It encapsulates an environment with arbitrary behind-the-scenes dynamics.\n    An environment can be partially or fully observed.\n    The main API methods that users of this class need to know are:\n    - :meth:`step` - Takes a step in the environment using an action returning the next observation, reward,\n      if the environment terminated and more information.\n    - :meth:`reset` - Resets the environment to an initial state, returning the initial observation.",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "ActType",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.core",
        "description": "repos_that_could_be_useful.gym.gym.core",
        "peekOfCode": "ActType = TypeVar(\"ActType\")\nclass Env(Generic[ObsType, ActType]):\n    r\"\"\"The main OpenAI Gym class.\n    It encapsulates an environment with arbitrary behind-the-scenes dynamics.\n    An environment can be partially or fully observed.\n    The main API methods that users of this class need to know are:\n    - :meth:`step` - Takes a step in the environment using an action returning the next observation, reward,\n      if the environment terminated and more information.\n    - :meth:`reset` - Resets the environment to an initial state, returning the initial observation.\n    - :meth:`render` - Renders the environment observation with modes depending on the output",
        "detail": "repos_that_could_be_useful.gym.gym.core",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class Error(Exception):\n    \"\"\"Error superclass.\"\"\"\n# Local errors\nclass Unregistered(Error):\n    \"\"\"Raised when the user requests an item from the registry that does not actually exist.\"\"\"\nclass UnregisteredEnv(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass NamespaceNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the namespace doesn't exist.\"\"\"\nclass NameNotFound(UnregisteredEnv):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "Unregistered",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class Unregistered(Error):\n    \"\"\"Raised when the user requests an item from the registry that does not actually exist.\"\"\"\nclass UnregisteredEnv(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass NamespaceNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the namespace doesn't exist.\"\"\"\nclass NameNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the name doesn't exist.\"\"\"\nclass VersionNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the version doesn't exist.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "UnregisteredEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class UnregisteredEnv(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass NamespaceNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the namespace doesn't exist.\"\"\"\nclass NameNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the name doesn't exist.\"\"\"\nclass VersionNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the version doesn't exist.\"\"\"\nclass UnregisteredBenchmark(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "NamespaceNotFound",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class NamespaceNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the namespace doesn't exist.\"\"\"\nclass NameNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the name doesn't exist.\"\"\"\nclass VersionNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the version doesn't exist.\"\"\"\nclass UnregisteredBenchmark(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass DeprecatedEnv(Error):\n    \"\"\"Raised when the user requests an env from the registry with an older version number than the latest env with the same name.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "NameNotFound",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class NameNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the name doesn't exist.\"\"\"\nclass VersionNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the version doesn't exist.\"\"\"\nclass UnregisteredBenchmark(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass DeprecatedEnv(Error):\n    \"\"\"Raised when the user requests an env from the registry with an older version number than the latest env with the same name.\"\"\"\nclass RegistrationError(Error):\n    \"\"\"Raised when the user attempts to register an invalid env. For example, an unversioned env when a versioned env exists.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "VersionNotFound",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class VersionNotFound(UnregisteredEnv):\n    \"\"\"Raised when the user requests an env from the registry where the version doesn't exist.\"\"\"\nclass UnregisteredBenchmark(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass DeprecatedEnv(Error):\n    \"\"\"Raised when the user requests an env from the registry with an older version number than the latest env with the same name.\"\"\"\nclass RegistrationError(Error):\n    \"\"\"Raised when the user attempts to register an invalid env. For example, an unversioned env when a versioned env exists.\"\"\"\nclass UnseedableEnv(Error):\n    \"\"\"Raised when the user tries to seed an env that does not support seeding.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "UnregisteredBenchmark",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class UnregisteredBenchmark(Unregistered):\n    \"\"\"Raised when the user requests an env from the registry that does not actually exist.\"\"\"\nclass DeprecatedEnv(Error):\n    \"\"\"Raised when the user requests an env from the registry with an older version number than the latest env with the same name.\"\"\"\nclass RegistrationError(Error):\n    \"\"\"Raised when the user attempts to register an invalid env. For example, an unversioned env when a versioned env exists.\"\"\"\nclass UnseedableEnv(Error):\n    \"\"\"Raised when the user tries to seed an env that does not support seeding.\"\"\"\nclass DependencyNotInstalled(Error):\n    \"\"\"Raised when the user has not installed a dependency.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "DeprecatedEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class DeprecatedEnv(Error):\n    \"\"\"Raised when the user requests an env from the registry with an older version number than the latest env with the same name.\"\"\"\nclass RegistrationError(Error):\n    \"\"\"Raised when the user attempts to register an invalid env. For example, an unversioned env when a versioned env exists.\"\"\"\nclass UnseedableEnv(Error):\n    \"\"\"Raised when the user tries to seed an env that does not support seeding.\"\"\"\nclass DependencyNotInstalled(Error):\n    \"\"\"Raised when the user has not installed a dependency.\"\"\"\nclass UnsupportedMode(Error):\n    \"\"\"Raised when the user requests a rendering mode not supported by the environment.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "RegistrationError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class RegistrationError(Error):\n    \"\"\"Raised when the user attempts to register an invalid env. For example, an unversioned env when a versioned env exists.\"\"\"\nclass UnseedableEnv(Error):\n    \"\"\"Raised when the user tries to seed an env that does not support seeding.\"\"\"\nclass DependencyNotInstalled(Error):\n    \"\"\"Raised when the user has not installed a dependency.\"\"\"\nclass UnsupportedMode(Error):\n    \"\"\"Raised when the user requests a rendering mode not supported by the environment.\"\"\"\nclass ResetNeeded(Error):\n    \"\"\"When the order enforcing is violated, i.e. step or render is called before reset.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "UnseedableEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class UnseedableEnv(Error):\n    \"\"\"Raised when the user tries to seed an env that does not support seeding.\"\"\"\nclass DependencyNotInstalled(Error):\n    \"\"\"Raised when the user has not installed a dependency.\"\"\"\nclass UnsupportedMode(Error):\n    \"\"\"Raised when the user requests a rendering mode not supported by the environment.\"\"\"\nclass ResetNeeded(Error):\n    \"\"\"When the order enforcing is violated, i.e. step or render is called before reset.\"\"\"\nclass ResetNotAllowed(Error):\n    \"\"\"When the monitor is active, raised when the user tries to step an environment that's not yet done.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "DependencyNotInstalled",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class DependencyNotInstalled(Error):\n    \"\"\"Raised when the user has not installed a dependency.\"\"\"\nclass UnsupportedMode(Error):\n    \"\"\"Raised when the user requests a rendering mode not supported by the environment.\"\"\"\nclass ResetNeeded(Error):\n    \"\"\"When the order enforcing is violated, i.e. step or render is called before reset.\"\"\"\nclass ResetNotAllowed(Error):\n    \"\"\"When the monitor is active, raised when the user tries to step an environment that's not yet done.\"\"\"\nclass InvalidAction(Error):\n    \"\"\"Raised when the user performs an action not contained within the action space.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "UnsupportedMode",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class UnsupportedMode(Error):\n    \"\"\"Raised when the user requests a rendering mode not supported by the environment.\"\"\"\nclass ResetNeeded(Error):\n    \"\"\"When the order enforcing is violated, i.e. step or render is called before reset.\"\"\"\nclass ResetNotAllowed(Error):\n    \"\"\"When the monitor is active, raised when the user tries to step an environment that's not yet done.\"\"\"\nclass InvalidAction(Error):\n    \"\"\"Raised when the user performs an action not contained within the action space.\"\"\"\n# API errors\nclass APIError(Error):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "ResetNeeded",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class ResetNeeded(Error):\n    \"\"\"When the order enforcing is violated, i.e. step or render is called before reset.\"\"\"\nclass ResetNotAllowed(Error):\n    \"\"\"When the monitor is active, raised when the user tries to step an environment that's not yet done.\"\"\"\nclass InvalidAction(Error):\n    \"\"\"Raised when the user performs an action not contained within the action space.\"\"\"\n# API errors\nclass APIError(Error):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "ResetNotAllowed",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class ResetNotAllowed(Error):\n    \"\"\"When the monitor is active, raised when the user tries to step an environment that's not yet done.\"\"\"\nclass InvalidAction(Error):\n    \"\"\"Raised when the user performs an action not contained within the action space.\"\"\"\n# API errors\nclass APIError(Error):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(\n        self,\n        message=None,",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "InvalidAction",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class InvalidAction(Error):\n    \"\"\"Raised when the user performs an action not contained within the action space.\"\"\"\n# API errors\nclass APIError(Error):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(\n        self,\n        message=None,\n        http_body=None,\n        http_status=None,",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "APIError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class APIError(Error):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(\n        self,\n        message=None,\n        http_body=None,\n        http_status=None,\n        json_body=None,\n        headers=None,\n    ):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "APIConnectionError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class APIConnectionError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\nclass InvalidRequestError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(\n        self,\n        message,\n        param,\n        http_body=None,\n        http_status=None,",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "InvalidRequestError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class InvalidRequestError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n    def __init__(\n        self,\n        message,\n        param,\n        http_body=None,\n        http_status=None,\n        json_body=None,\n        headers=None,",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "AuthenticationError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class AuthenticationError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\nclass RateLimitError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n# Video errors\nclass VideoRecorderError(Error):\n    \"\"\"Unused error.\"\"\"\nclass InvalidFrame(Error):\n    \"\"\"Error message when an invalid frame is captured.\"\"\"\n# Wrapper errors",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "RateLimitError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class RateLimitError(APIError):\n    \"\"\"Deprecated, to be removed at gym 1.0.\"\"\"\n# Video errors\nclass VideoRecorderError(Error):\n    \"\"\"Unused error.\"\"\"\nclass InvalidFrame(Error):\n    \"\"\"Error message when an invalid frame is captured.\"\"\"\n# Wrapper errors\nclass DoubleWrapperError(Error):\n    \"\"\"Error message for when using double wrappers.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "VideoRecorderError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class VideoRecorderError(Error):\n    \"\"\"Unused error.\"\"\"\nclass InvalidFrame(Error):\n    \"\"\"Error message when an invalid frame is captured.\"\"\"\n# Wrapper errors\nclass DoubleWrapperError(Error):\n    \"\"\"Error message for when using double wrappers.\"\"\"\nclass WrapAfterConfigureError(Error):\n    \"\"\"Error message for using wrap after configure.\"\"\"\nclass RetriesExceededError(Error):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "InvalidFrame",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class InvalidFrame(Error):\n    \"\"\"Error message when an invalid frame is captured.\"\"\"\n# Wrapper errors\nclass DoubleWrapperError(Error):\n    \"\"\"Error message for when using double wrappers.\"\"\"\nclass WrapAfterConfigureError(Error):\n    \"\"\"Error message for using wrap after configure.\"\"\"\nclass RetriesExceededError(Error):\n    \"\"\"Error message for retries exceeding set number.\"\"\"\n# Vectorized environments errors",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "DoubleWrapperError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class DoubleWrapperError(Error):\n    \"\"\"Error message for when using double wrappers.\"\"\"\nclass WrapAfterConfigureError(Error):\n    \"\"\"Error message for using wrap after configure.\"\"\"\nclass RetriesExceededError(Error):\n    \"\"\"Error message for retries exceeding set number.\"\"\"\n# Vectorized environments errors\nclass AlreadyPendingCallError(Exception):\n    \"\"\"Raised when `reset`, or `step` is called asynchronously (e.g. with `reset_async`, or `step_async` respectively), and `reset_async`, or `step_async` (respectively) is called again (without a complete call to `reset_wait`, or `step_wait` respectively).\"\"\"\n    def __init__(self, message: str, name: str):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "WrapAfterConfigureError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class WrapAfterConfigureError(Error):\n    \"\"\"Error message for using wrap after configure.\"\"\"\nclass RetriesExceededError(Error):\n    \"\"\"Error message for retries exceeding set number.\"\"\"\n# Vectorized environments errors\nclass AlreadyPendingCallError(Exception):\n    \"\"\"Raised when `reset`, or `step` is called asynchronously (e.g. with `reset_async`, or `step_async` respectively), and `reset_async`, or `step_async` (respectively) is called again (without a complete call to `reset_wait`, or `step_wait` respectively).\"\"\"\n    def __init__(self, message: str, name: str):\n        \"\"\"Initialises the exception with name attributes.\"\"\"\n        super().__init__(message)",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "RetriesExceededError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class RetriesExceededError(Error):\n    \"\"\"Error message for retries exceeding set number.\"\"\"\n# Vectorized environments errors\nclass AlreadyPendingCallError(Exception):\n    \"\"\"Raised when `reset`, or `step` is called asynchronously (e.g. with `reset_async`, or `step_async` respectively), and `reset_async`, or `step_async` (respectively) is called again (without a complete call to `reset_wait`, or `step_wait` respectively).\"\"\"\n    def __init__(self, message: str, name: str):\n        \"\"\"Initialises the exception with name attributes.\"\"\"\n        super().__init__(message)\n        self.name = name\nclass NoAsyncCallError(Exception):",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "AlreadyPendingCallError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class AlreadyPendingCallError(Exception):\n    \"\"\"Raised when `reset`, or `step` is called asynchronously (e.g. with `reset_async`, or `step_async` respectively), and `reset_async`, or `step_async` (respectively) is called again (without a complete call to `reset_wait`, or `step_wait` respectively).\"\"\"\n    def __init__(self, message: str, name: str):\n        \"\"\"Initialises the exception with name attributes.\"\"\"\n        super().__init__(message)\n        self.name = name\nclass NoAsyncCallError(Exception):\n    \"\"\"Raised when an asynchronous `reset`, or `step` is not running, but `reset_wait`, or `step_wait` (respectively) is called.\"\"\"\n    def __init__(self, message: str, name: str):\n        \"\"\"Initialises the exception with name attributes.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "NoAsyncCallError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class NoAsyncCallError(Exception):\n    \"\"\"Raised when an asynchronous `reset`, or `step` is not running, but `reset_wait`, or `step_wait` (respectively) is called.\"\"\"\n    def __init__(self, message: str, name: str):\n        \"\"\"Initialises the exception with name attributes.\"\"\"\n        super().__init__(message)\n        self.name = name\nclass ClosedEnvironmentError(Exception):\n    \"\"\"Trying to call `reset`, or `step`, while the environment is closed.\"\"\"\nclass CustomSpaceError(Exception):\n    \"\"\"The space is a custom gym.Space instance, and is not supported by `AsyncVectorEnv` with `shared_memory=True`.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "ClosedEnvironmentError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class ClosedEnvironmentError(Exception):\n    \"\"\"Trying to call `reset`, or `step`, while the environment is closed.\"\"\"\nclass CustomSpaceError(Exception):\n    \"\"\"The space is a custom gym.Space instance, and is not supported by `AsyncVectorEnv` with `shared_memory=True`.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "CustomSpaceError",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.gym.error",
        "description": "repos_that_could_be_useful.gym.gym.error",
        "peekOfCode": "class CustomSpaceError(Exception):\n    \"\"\"The space is a custom gym.Space instance, and is not supported by `AsyncVectorEnv` with `shared_memory=True`.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.error",
        "documentation": {}
    },
    {
        "label": "set_level",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level\ndef debug(msg: str, *args: object):\n    \"\"\"Logs a debug message to the user.\"\"\"\n    if min_level <= DEBUG:\n        print(f\"DEBUG: {msg % args}\", file=sys.stderr)\ndef info(msg: str, *args: object):\n    \"\"\"Logs an info message to the user.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def debug(msg: str, *args: object):\n    \"\"\"Logs a debug message to the user.\"\"\"\n    if min_level <= DEBUG:\n        print(f\"DEBUG: {msg % args}\", file=sys.stderr)\ndef info(msg: str, *args: object):\n    \"\"\"Logs an info message to the user.\"\"\"\n    if min_level <= INFO:\n        print(f\"INFO: {msg % args}\", file=sys.stderr)\ndef warn(\n    msg: str,",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def info(msg: str, *args: object):\n    \"\"\"Logs an info message to the user.\"\"\"\n    if min_level <= INFO:\n        print(f\"INFO: {msg % args}\", file=sys.stderr)\ndef warn(\n    msg: str,\n    *args: object,\n    category: Optional[Type[Warning]] = None,\n    stacklevel: int = 1,\n):",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "warn",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def warn(\n    msg: str,\n    *args: object,\n    category: Optional[Type[Warning]] = None,\n    stacklevel: int = 1,\n):\n    \"\"\"Raises a warning to the user if the min_level <= WARN.\n    Args:\n        msg: The message to warn the user\n        *args: Additional information to warn the user",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "deprecation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def deprecation(msg: str, *args: object):\n    \"\"\"Logs a deprecation warning to users.\"\"\"\n    warn(msg, *args, category=DeprecationWarning, stacklevel=2)\ndef error(msg: str, *args: object):\n    \"\"\"Logs an error message if min_level <= ERROR in red on the sys.stderr.\"\"\"\n    if min_level <= ERROR:\n        print(colorize(f\"ERROR: {msg % args}\", \"red\"), file=sys.stderr)\n# DEPRECATED:\nsetLevel = set_level",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "def error(msg: str, *args: object):\n    \"\"\"Logs an error message if min_level <= ERROR in red on the sys.stderr.\"\"\"\n    if min_level <= ERROR:\n        print(colorize(f\"ERROR: {msg % args}\", \"red\"), file=sys.stderr)\n# DEPRECATED:\nsetLevel = set_level",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "DEBUG = 10\nINFO = 20\nWARN = 30\nERROR = 40\nDISABLED = 50\nmin_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "INFO = 20\nWARN = 30\nERROR = 40\nDISABLED = 50\nmin_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "WARN = 30\nERROR = 40\nDISABLED = 50\nmin_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level\ndef debug(msg: str, *args: object):",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "ERROR",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "ERROR = 40\nDISABLED = 50\nmin_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level\ndef debug(msg: str, *args: object):\n    \"\"\"Logs a debug message to the user.\"\"\"",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "DISABLED",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "DISABLED = 50\nmin_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level\ndef debug(msg: str, *args: object):\n    \"\"\"Logs a debug message to the user.\"\"\"\n    if min_level <= DEBUG:",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "min_level",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "min_level = 30\nwarnings.simplefilter(\"once\", DeprecationWarning)\ndef set_level(level: int):\n    \"\"\"Set logging threshold on current logger.\"\"\"\n    global min_level\n    min_level = level\ndef debug(msg: str, *args: object):\n    \"\"\"Logs a debug message to the user.\"\"\"\n    if min_level <= DEBUG:\n        print(f\"DEBUG: {msg % args}\", file=sys.stderr)",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "setLevel",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.logger",
        "description": "repos_that_could_be_useful.gym.gym.logger",
        "peekOfCode": "setLevel = set_level",
        "detail": "repos_that_could_be_useful.gym.gym.logger",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.gym.version",
        "description": "repos_that_could_be_useful.gym.gym.version",
        "peekOfCode": "VERSION = \"0.23.1\"",
        "detail": "repos_that_could_be_useful.gym.gym.version",
        "documentation": {}
    },
    {
        "label": "should_skip_env_spec_for_tests",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "description": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "peekOfCode": "def should_skip_env_spec_for_tests(spec):\n    # We skip tests for envs that require dependencies or are otherwise\n    # troublesome to run frequently\n    ep = spec.entry_point\n    # Skip mujoco tests for pull request CI\n    if skip_mujoco and ep.startswith(\"gym.envs.mujoco\"):\n        return True\n    try:\n        import gym.envs.atari  # noqa:F401\n    except ImportError:",
        "detail": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "SKIP_MUJOCO_WARNING_MESSAGE",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "description": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "peekOfCode": "SKIP_MUJOCO_WARNING_MESSAGE = (\n    \"Cannot run mujoco test (either license key not found or mujoco not\"\n    \"installed properly).\"\n)\nskip_mujoco = not (os.environ.get(\"MUJOCO_KEY\"))\nif not skip_mujoco:\n    try:\n        import mujoco_py  # noqa:F401\n    except ImportError:\n        skip_mujoco = True",
        "detail": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "skip_mujoco",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "description": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "peekOfCode": "skip_mujoco = not (os.environ.get(\"MUJOCO_KEY\"))\nif not skip_mujoco:\n    try:\n        import mujoco_py  # noqa:F401\n    except ImportError:\n        skip_mujoco = True\ndef should_skip_env_spec_for_tests(spec):\n    # We skip tests for envs that require dependencies or are otherwise\n    # troublesome to run frequently\n    ep = spec.entry_point",
        "detail": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "spec_list",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "description": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "peekOfCode": "spec_list = [\n    spec\n    for spec in sorted(envs.registry.values(), key=lambda x: x.id)\n    if spec.entry_point is not None and not should_skip_env_spec_for_tests(spec)\n]",
        "detail": "repos_that_could_be_useful.gym.tests.envs.spec_list",
        "documentation": {}
    },
    {
        "label": "test_serialize_deserialize",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "peekOfCode": "def test_serialize_deserialize(environment_id):\n    env = envs.make(environment_id)\n    env.reset()\n    with pytest.raises(ValueError, match=\"Action dimension mismatch\"):\n        env.step([0.1])\n    with pytest.raises(ValueError, match=\"Action dimension mismatch\"):\n        env.step(0.1)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_IDS",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "peekOfCode": "ENVIRONMENT_IDS = (\"HalfCheetah-v2\",)\n@pytest.mark.skipif(skip_mujoco, reason=SKIP_MUJOCO_WARNING_MESSAGE)\n@pytest.mark.parametrize(\"environment_id\", ENVIRONMENT_IDS)\ndef test_serialize_deserialize(environment_id):\n    env = envs.make(environment_id)\n    env.reset()\n    with pytest.raises(ValueError, match=\"Action dimension mismatch\"):\n        env.step([0.1])\n    with pytest.raises(ValueError, match=\"Action dimension mismatch\"):\n        env.step(0.1)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_action_dim_check",
        "documentation": {}
    },
    {
        "label": "test_ale_legacy_env_specs",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_atari_legacy_env_specs",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_atari_legacy_env_specs",
        "peekOfCode": "def test_ale_legacy_env_specs():\n    versions = [\"-v0\", \"-v4\"]\n    suffixes = [\"\", \"NoFrameskip\", \"Deterministic\"]\n    obs_types = [\"\", \"-ram\"]\n    games = [\n        \"adventure\",\n        \"air_raid\",\n        \"alien\",\n        \"amidar\",\n        \"assault\",",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_atari_legacy_env_specs",
        "documentation": {}
    },
    {
        "label": "test_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "peekOfCode": "def test_env(spec):\n    \"\"\"Run a rollout with two environments and assert equality.\n    This test run a rollout of NUM_STEPS steps with two environments\n    initialized with the same seed and assert that:\n    - observation after first reset are the same\n    - same actions are sampled by the two envs\n    - observations are contained in the observation space\n    - obs, rew, done and info are equals between the two envs\n    Args:\n        spec (EnvSpec): Environment specification",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "documentation": {}
    },
    {
        "label": "assert_equals",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "peekOfCode": "def assert_equals(a, b, prefix=None):\n    \"\"\"Assert equality of data structures `a` and `b`.\n    Args:\n        a: first data structure\n        b: second data structure\n        prefix: prefix for failed assertion message for types and dicts\n    \"\"\"\n    assert type(a) == type(b), f\"{prefix}Differing types: {a} and {b}\"\n    if isinstance(a, dict):\n        assert list(a.keys()) == list(b.keys()), f\"{prefix}Key sets differ: {a} and {b}\"",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_determinism",
        "documentation": {}
    },
    {
        "label": "test_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "peekOfCode": "def test_env(spec):\n    # Capture warnings\n    with pytest.warns(None) as warnings:\n        env = spec.make()\n    # Test if env adheres to Gym API\n    check_env(env, warn=True, skip_render_check=True)\n    # Check that dtype is explicitly declared for gym.Box spaces\n    for warning_msg in warnings:\n        assert \"autodetected dtype\" not in str(warning_msg.message)\n    ob_space = env.observation_space",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "documentation": {}
    },
    {
        "label": "test_reset_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "peekOfCode": "def test_reset_info(spec):\n    with pytest.warns(None):\n        env = spec.make()\n    ob_space = env.observation_space\n    obs = env.reset()\n    assert ob_space.contains(obs)\n    obs = env.reset(return_info=False)\n    assert ob_space.contains(obs)\n    obs, info = env.reset(return_info=True)\n    assert ob_space.contains(obs)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "documentation": {}
    },
    {
        "label": "test_env_render_result_is_immutable",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "peekOfCode": "def test_env_render_result_is_immutable():\n    environs = [\n        envs.make(\"Taxi-v3\"),\n        envs.make(\"FrozenLake-v1\"),\n    ]\n    for env in environs:\n        env.reset()\n        output = env.render(mode=\"ansi\")\n        assert isinstance(output, str)\n        env.close()",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_envs",
        "documentation": {}
    },
    {
        "label": "test_frozenlake_dfs_map_generation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_frozenlake_dfs",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_frozenlake_dfs",
        "peekOfCode": "def test_frozenlake_dfs_map_generation():\n    def frozenlake_dfs_path_exists(res):\n        frontier, discovered = [], set()\n        frontier.append((0, 0))\n        while frontier:\n            r, c = frontier.pop()\n            if not (r, c) in discovered:\n                discovered.add((r, c))\n                directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n                for x, y in directions:",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_frozenlake_dfs",
        "documentation": {}
    },
    {
        "label": "test_lunar_lander",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "peekOfCode": "def test_lunar_lander():\n    _test_lander(LunarLander(), seed=0)\n@pytest.mark.skipif(Box2D is None, reason=\"Box2D not installed\")\ndef test_lunar_lander_continuous():\n    _test_lander(LunarLander(continuous=True), seed=0)\n@pytest.mark.skipif(Box2D is None, reason=\"Box2D not installed\")\ndef _test_lander(env, seed=None, render=False):\n    total_reward = demo_heuristic_lander(env, seed=seed, render=render)\n    assert total_reward > 100",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "documentation": {}
    },
    {
        "label": "test_lunar_lander_continuous",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "peekOfCode": "def test_lunar_lander_continuous():\n    _test_lander(LunarLander(continuous=True), seed=0)\n@pytest.mark.skipif(Box2D is None, reason=\"Box2D not installed\")\ndef _test_lander(env, seed=None, render=False):\n    total_reward = demo_heuristic_lander(env, seed=seed, render=render)\n    assert total_reward > 100",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_lunar_lander",
        "documentation": {}
    },
    {
        "label": "Mujocov2Tov3ConversionTest",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "peekOfCode": "class Mujocov2Tov3ConversionTest(unittest.TestCase):\n    def test_environments_match(self):\n        test_cases = (\n            {\"old_id\": \"Swimmer-v2\", \"new_id\": \"Swimmer-v3\"},\n            {\"old_id\": \"Hopper-v2\", \"new_id\": \"Hopper-v3\"},\n            {\"old_id\": \"Walker2d-v2\", \"new_id\": \"Walker2d-v3\"},\n            {\"old_id\": \"HalfCheetah-v2\", \"new_id\": \"HalfCheetah-v3\"},\n            {\"old_id\": \"Ant-v2\", \"new_id\": \"Ant-v3\"},\n            {\"old_id\": \"Humanoid-v2\", \"new_id\": \"Humanoid-v3\"},\n        )",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "documentation": {}
    },
    {
        "label": "verify_environments_match",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "peekOfCode": "def verify_environments_match(\n    old_environment_id, new_environment_id, seed=1, num_actions=1000\n):\n    old_environment = envs.make(old_environment_id)\n    new_environment = envs.make(new_environment_id)\n    old_reset_observation = old_environment.reset(seed=seed)\n    new_reset_observation = new_environment.reset(seed=seed)\n    np.testing.assert_allclose(old_reset_observation, new_reset_observation)\n    for i in range(num_actions):\n        action = old_environment.action_space.sample()",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_mujoco_v2_to_v3_conversion",
        "documentation": {}
    },
    {
        "label": "ArgumentEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "class ArgumentEnv(gym.Env):\n    def __init__(self, arg1, arg2, arg3):\n        self.arg1 = arg1\n        self.arg2 = arg2\n        self.arg3 = arg3\ngym.register(\n    id=\"test.ArgumentEnv-v0\",\n    entry_point=\"tests.envs.test_registration:ArgumentEnv\",\n    kwargs={\n        \"arg1\": \"arg1\",",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "register_some_envs",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def register_some_envs():\n    namespace = \"MyAwesomeNamespace\"\n    versioned_name = \"MyAwesomeVersionedEnv\"\n    unversioned_name = \"MyAwesomeUnversionedEnv\"\n    versions = [1, 3, 5]\n    for version in versions:\n        env_id = f\"{namespace}/{versioned_name}-v{version}\"\n        gym.register(\n            id=env_id,\n            entry_point=\"tests.envs.test_registration:ArgumentEnv\",",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_make",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_make():\n    env = envs.make(\"CartPole-v1\")\n    assert env.spec.id == \"CartPole-v1\"\n    assert isinstance(env.unwrapped, cartpole.CartPoleEnv)\n@pytest.mark.parametrize(\n    \"env_id, namespace, name, version\",\n    [\n        (\n            \"MyAwesomeNamespace/MyAwesomeEnv-v0\",\n            \"MyAwesomeNamespace\",",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_register",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_register(env_id, namespace, name, version):\n    register(env_id)\n    assert gym.envs.spec(env_id).id == env_id\n    full_name = f\"{name}\"\n    if namespace:\n        full_name = f\"{namespace}/{full_name}\"\n    if version is not None:\n        full_name = f\"{full_name}-v{version}\"\n    assert full_name in gym.envs.registry.keys()\n    del gym.envs.registry[env_id]",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_register_error",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_register_error(env_id):\n    with pytest.raises(error.Error, match=\"Malformed environment ID\"):\n        register(env_id)\n@pytest.mark.parametrize(\n    \"env_id_input, env_id_suggested\",\n    [\n        (\"cartpole-v1\", \"CartPole\"),\n        (\"blackjack-v1\", \"Blackjack\"),\n        (\"Blackjock-v1\", \"Blackjack\"),\n        (\"mountaincarcontinuous-v0\", \"MountainCarContinuous\"),",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_env_suggestions",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_env_suggestions(register_some_envs, env_id_input, env_id_suggested):\n    with pytest.raises(\n        error.UnregisteredEnv, match=f\"Did you mean: `{env_id_suggested}` ?\"\n    ):\n        envs.make(env_id_input)\n@pytest.mark.parametrize(\n    \"env_id_input, suggested_versions, default_version\",\n    [\n        (\"CartPole-v12\", \"`v0`, `v1`\", False),\n        (\"Blackjack-v10\", \"`v1`\", False),",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_env_version_suggestions",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_env_version_suggestions(\n    register_some_envs, env_id_input, suggested_versions, default_version\n):\n    if default_version:\n        match_str = \"provides the default version\"\n        with pytest.raises(\n            error.DeprecatedEnv,\n            match=match_str,\n        ):\n            envs.make(env_id_input)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_make_with_kwargs",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_make_with_kwargs():\n    env = envs.make(\"test.ArgumentEnv-v0\", arg2=\"override_arg2\", arg3=\"override_arg3\")\n    assert env.spec.id == \"test.ArgumentEnv-v0\"\n    assert isinstance(env.unwrapped, ArgumentEnv)\n    assert env.arg1 == \"arg1\"\n    assert env.arg2 == \"override_arg2\"\n    assert env.arg3 == \"override_arg3\"\n@pytest.mark.filterwarnings(\n    \"ignore:.*The environment Humanoid-v0 is out of date. You should consider upgrading to \"\n    \"version `v3` with the environment ID `Humanoid-v3`.*\"",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_make_deprecated",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_make_deprecated():\n    try:\n        envs.make(\"Humanoid-v0\")\n    except error.Error:\n        pass\n    else:\n        assert False\ndef test_spec():\n    spec = envs.spec(\"CartPole-v1\")\n    assert spec.id == \"CartPole-v1\"",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_spec",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_spec():\n    spec = envs.spec(\"CartPole-v1\")\n    assert spec.id == \"CartPole-v1\"\ndef test_spec_with_kwargs():\n    map_name_value = \"8x8\"\n    env = gym.make(\"FrozenLake-v1\", map_name=map_name_value)\n    assert env.spec.kwargs[\"map_name\"] == map_name_value\ndef test_missing_lookup():\n    register(id=\"Test1-v0\", entry_point=None)\n    register(id=\"Test1-v15\", entry_point=None)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_spec_with_kwargs",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_spec_with_kwargs():\n    map_name_value = \"8x8\"\n    env = gym.make(\"FrozenLake-v1\", map_name=map_name_value)\n    assert env.spec.kwargs[\"map_name\"] == map_name_value\ndef test_missing_lookup():\n    register(id=\"Test1-v0\", entry_point=None)\n    register(id=\"Test1-v15\", entry_point=None)\n    register(id=\"Test1-v9\", entry_point=None)\n    register(id=\"Other1-v100\", entry_point=None)\n    with pytest.raises(error.DeprecatedEnv):",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_missing_lookup",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_missing_lookup():\n    register(id=\"Test1-v0\", entry_point=None)\n    register(id=\"Test1-v15\", entry_point=None)\n    register(id=\"Test1-v9\", entry_point=None)\n    register(id=\"Other1-v100\", entry_point=None)\n    with pytest.raises(error.DeprecatedEnv):\n        spec(\"Test1-v1\")\n    try:\n        spec(\"Test1-v1000\")\n    except error.UnregisteredEnv:",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_malformed_lookup",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_malformed_lookup():\n    try:\n        spec(\"Breakout-v0\")\n    except error.Error as e:\n        assert \"Malformed environment ID\" in f\"{e}\", f\"Unexpected message: {e}\"\n    else:\n        assert False\ndef test_versioned_lookups():\n    register(\"test/Test2-v5\")\n    with pytest.raises(error.VersionNotFound):",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_versioned_lookups",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_versioned_lookups():\n    register(\"test/Test2-v5\")\n    with pytest.raises(error.VersionNotFound):\n        spec(\"test/Test2-v9\")\n    with pytest.raises(error.DeprecatedEnv):\n        spec(\"test/Test2-v4\")\n    assert spec(\"test/Test2-v5\")\ndef test_default_lookups():\n    register(\"test/Test3\")\n    with pytest.raises(error.DeprecatedEnv):",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_default_lookups",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_default_lookups():\n    register(\"test/Test3\")\n    with pytest.raises(error.DeprecatedEnv):\n        spec(\"test/Test3-v0\")\n    # Lookup default\n    spec(\"test/Test3\")\ndef test_register_versioned_unversioned():\n    # Register versioned then unversioned\n    versioned_env = \"Test/MyEnv-v0\"\n    register(versioned_env)",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_register_versioned_unversioned",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_register_versioned_unversioned():\n    # Register versioned then unversioned\n    versioned_env = \"Test/MyEnv-v0\"\n    register(versioned_env)\n    assert gym.envs.spec(versioned_env).id == versioned_env\n    unversioned_env = \"Test/MyEnv\"\n    with pytest.raises(error.RegistrationError):\n        register(unversioned_env)\n    # Clean everything\n    del gym.envs.registry[versioned_env]",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_return_latest_versioned_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_return_latest_versioned_env(register_some_envs):\n    with pytest.warns(UserWarning):\n        env = envs.make(\"MyAwesomeNamespace/MyAwesomeVersionedEnv\")\n    assert env.spec.id == \"MyAwesomeNamespace/MyAwesomeVersionedEnv-v5\"\ndef test_namespace():\n    # Check if the namespace context manager works\n    with registration.namespace(\"MyDefaultNamespace\"):\n        register(\"MyDefaultEnvironment-v0\")\n    register(\"MyDefaultEnvironment-v1\")\n    assert \"MyDefaultNamespace/MyDefaultEnvironment-v0\" in registry",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_namespace",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "description": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "peekOfCode": "def test_namespace():\n    # Check if the namespace context manager works\n    with registration.namespace(\"MyDefaultNamespace\"):\n        register(\"MyDefaultEnvironment-v0\")\n    register(\"MyDefaultEnvironment-v1\")\n    assert \"MyDefaultNamespace/MyDefaultEnvironment-v0\" in registry\n    assert \"MyDefaultEnvironment-v1\" in registry\n    del registry[\"MyDefaultNamespace/MyDefaultEnvironment-v0\"]\n    del registry[\"MyDefaultEnvironment-v1\"]",
        "detail": "repos_that_could_be_useful.gym.tests.envs.test_registration",
        "documentation": {}
    },
    {
        "label": "test_roundtripping",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_roundtripping(space):\n    sample_1 = space.sample()\n    sample_2 = space.sample()\n    assert space.contains(sample_1)\n    assert space.contains(sample_2)\n    json_rep = space.to_jsonable([sample_1, sample_2])\n    json_roundtripped = json.loads(json.dumps(json_rep))\n    samples_after_roundtrip = space.from_jsonable(json_roundtripped)\n    sample_1_prime, sample_2_prime = samples_after_roundtrip\n    s1 = space.to_jsonable([sample_1])",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_equality",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_equality(space):\n    space1 = space\n    space2 = copy.deepcopy(space)\n    assert space1 == space2, f\"Expected {space1} to equal {space2}\"\n@pytest.mark.parametrize(\n    \"spaces\",\n    [\n        (Discrete(3), Discrete(4)),\n        (Discrete(3), Discrete(3, start=-1)),\n        (MultiDiscrete([2, 2, 100]), MultiDiscrete([2, 2, 8])),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_inequality",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_inequality(spaces):\n    space1, space2 = spaces\n    assert space1 != space2, f\"Expected {space1} != {space2}\"\n@pytest.mark.parametrize(\n    \"space\",\n    [\n        Discrete(5),\n        Discrete(8, start=-20),\n        Box(low=0, high=255, shape=(2,), dtype=\"uint8\"),\n        Box(low=-np.inf, high=np.inf, shape=(3, 3)),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_sample",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_sample(space):\n    space.seed(0)\n    n_trials = 100\n    samples = np.array([space.sample() for _ in range(n_trials)])\n    expected_mean = 0.0\n    if isinstance(space, Box):\n        if space.is_bounded():\n            expected_mean = (space.high + space.low) / 2\n        elif space.is_bounded(\"below\"):\n            expected_mean = 1 + space.low",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_class_inequality",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_class_inequality(spaces):\n    assert spaces[0] == spaces[0]\n    assert spaces[1] == spaces[1]\n    assert spaces[0] != spaces[1]\n    assert spaces[1] != spaces[0]\n@pytest.mark.parametrize(\n    \"space_fn\",\n    [\n        lambda: Dict(space1=\"abc\"),\n        lambda: Dict({\"space1\": \"abc\"}),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_bad_space_calls",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_bad_space_calls(space_fn):\n    with pytest.raises(AssertionError):\n        space_fn()\ndef test_seed_Dict():\n    test_space = Dict(\n        {\n            \"a\": Box(low=0, high=1, shape=(3, 3)),\n            \"b\": Dict(\n                {\n                    \"b_1\": Box(low=-100, high=100, shape=(2,)),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_seed_Dict",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_seed_Dict():\n    test_space = Dict(\n        {\n            \"a\": Box(low=0, high=1, shape=(3, 3)),\n            \"b\": Dict(\n                {\n                    \"b_1\": Box(low=-100, high=100, shape=(2,)),\n                    \"b_2\": Box(low=-1, high=1, shape=(2,)),\n                }\n            ),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_box_dtype_check",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_box_dtype_check():\n    # Related Issues:\n    # https://github.com/openai/gym/issues/2357\n    # https://github.com/openai/gym/issues/2298\n    space = Box(0, 2, tuple(), dtype=np.float32)\n    # casting will match the correct type\n    assert space.contains(np.array(0.5, dtype=np.float32))\n    # float64 is not in float32 space\n    assert not space.contains(np.array(0.5))\n    assert not space.contains(np.array(1))",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_seed_returns_list",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_seed_returns_list(space):\n    def assert_integer_list(seed):\n        assert isinstance(seed, list)\n        assert len(seed) >= 1\n        assert all([isinstance(s, int) for s in seed])\n    assert_integer_list(space.seed(None))\n    assert_integer_list(space.seed(0))\ndef convert_sample_hashable(sample):\n    if isinstance(sample, np.ndarray):\n        return tuple(sample.tolist())",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "convert_sample_hashable",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def convert_sample_hashable(sample):\n    if isinstance(sample, np.ndarray):\n        return tuple(sample.tolist())\n    if isinstance(sample, (list, tuple)):\n        return tuple(convert_sample_hashable(s) for s in sample)\n    if isinstance(sample, dict):\n        return tuple(\n            (key, convert_sample_hashable(value)) for key, value in sample.items()\n        )\n    return sample",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "sample_equal",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def sample_equal(sample1, sample2):\n    return convert_sample_hashable(sample1) == convert_sample_hashable(sample2)\n@pytest.mark.parametrize(\n    \"space\",\n    [\n        Discrete(3),\n        Discrete(3, start=-4),\n        Box(low=0.0, high=np.inf, shape=(2, 2)),\n        Tuple([Discrete(5), Discrete(10)]),\n        Tuple(",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_seed_reproducibility",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_seed_reproducibility(space):\n    space1 = space\n    space2 = copy.deepcopy(space)\n    space1.seed(None)\n    space2.seed(None)\n    assert space1.seed(0) == space2.seed(0)\n    assert sample_equal(space1.sample(), space2.sample())\n@pytest.mark.parametrize(\n    \"space\",\n    [",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_seed_subspace_incorrelated",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_seed_subspace_incorrelated(space):\n    subspaces = space.spaces if isinstance(space, Tuple) else space.spaces.values()\n    space.seed(0)\n    states = [\n        convert_sample_hashable(subspace.np_random.bit_generator.state)\n        for subspace in subspaces\n    ]\n    assert len(states) == len(set(states))\ndef test_tuple():\n    spaces = [Discrete(5), Discrete(10), Discrete(5)]",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_tuple",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_tuple():\n    spaces = [Discrete(5), Discrete(10), Discrete(5)]\n    space_tuple = Tuple(spaces)\n    assert len(space_tuple) == len(spaces)\n    assert space_tuple.count(Discrete(5)) == 2\n    assert space_tuple.count(MultiBinary(2)) == 0\n    for i, space in enumerate(space_tuple):\n        assert space == spaces[i]\n    for i, space in enumerate(reversed(space_tuple)):\n        assert space == spaces[len(spaces) - 1 - i]",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_multidiscrete_as_tuple",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_multidiscrete_as_tuple():\n    # 1D multi-discrete\n    space = MultiDiscrete([3, 4, 5])\n    assert space.shape == (3,)\n    assert space[0] == Discrete(3)\n    assert space[0:1] == MultiDiscrete([3])\n    assert space[0:2] == MultiDiscrete([3, 4])\n    assert space[:] == space and space[:] is not space\n    assert len(space) == 3\n    # 2D multi-discrete",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_multidiscrete_subspace_reproducibility",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_multidiscrete_subspace_reproducibility():\n    # 1D multi-discrete\n    space = MultiDiscrete([100, 200, 300])\n    space.seed(None)\n    assert sample_equal(space[0].sample(), space[0].sample())\n    assert sample_equal(space[0:1].sample(), space[0:1].sample())\n    assert sample_equal(space[0:2].sample(), space[0:2].sample())\n    assert sample_equal(space[:].sample(), space[:].sample())\n    assert sample_equal(space[:].sample(), space.sample())\n    # 2D multi-discrete",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_space_legacy_state_pickling",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_space_legacy_state_pickling():\n    legacy_state = {\n        \"shape\": (\n            1,\n            2,\n            3,\n        ),\n        \"dtype\": np.int64,\n        \"np_random\": np.random.default_rng(),\n        \"n\": 3,",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_infinite_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_infinite_space(space):\n    # for this test, make sure that spaces that are passed in have only 0 or infinite bounds\n    # because space.high and space.low are both modified within the init\n    # so we check for infinite when we know it's not 0\n    space.seed(0)\n    assert np.all(space.high > space.low), \"High bound not higher than low bound\"\n    sample = space.sample()\n    # check if space contains sample\n    assert space.contains(\n        sample",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_discrete_legacy_state_pickling",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_discrete_legacy_state_pickling():\n    legacy_state = {\n        \"n\": 3,\n    }\n    d = Discrete(1)\n    assert \"start\" in d.__dict__\n    del d.__dict__[\"start\"]  # legacy did not include start param\n    assert \"start\" not in d.__dict__\n    d.__setstate__(legacy_state)\n    assert d.start == 0",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_pickle",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "peekOfCode": "def test_pickle(space):\n    space.sample()\n    # Pickle and unpickle with a string\n    pickled = pickle.dumps(space)\n    space2 = pickle.loads(pickled)\n    # Pickle and unpickle with a file\n    with tempfile.TemporaryFile() as f:\n        pickle.dump(space, f)\n        f.seek(0)\n        space3 = pickle.load(f)",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_flatdim",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatdim(space, flatdim):\n    dim = utils.flatdim(space)\n    assert dim == flatdim, f\"Expected {dim} to equal {flatdim}\"\n@pytest.mark.parametrize(\"space\", spaces)\ndef test_flatten_space_boxes(space):\n    flat_space = utils.flatten_space(space)\n    assert isinstance(flat_space, Box), f\"Expected {type(flat_space)} to equal {Box}\"\n    flatdim = utils.flatdim(space)\n    (single_dim,) = flat_space.shape\n    assert single_dim == flatdim, f\"Expected {single_dim} to equal {flatdim}\"",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flatten_space_boxes",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatten_space_boxes(space):\n    flat_space = utils.flatten_space(space)\n    assert isinstance(flat_space, Box), f\"Expected {type(flat_space)} to equal {Box}\"\n    flatdim = utils.flatdim(space)\n    (single_dim,) = flat_space.shape\n    assert single_dim == flatdim, f\"Expected {single_dim} to equal {flatdim}\"\n@pytest.mark.parametrize(\"space\", spaces)\ndef test_flat_space_contains_flat_points(space):\n    some_samples = [space.sample() for _ in range(10)]\n    flattened_samples = [utils.flatten(space, sample) for sample in some_samples]",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flat_space_contains_flat_points",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flat_space_contains_flat_points(space):\n    some_samples = [space.sample() for _ in range(10)]\n    flattened_samples = [utils.flatten(space, sample) for sample in some_samples]\n    flat_space = utils.flatten_space(space)\n    for i, flat_sample in enumerate(flattened_samples):\n        assert (\n            flat_sample in flat_space\n        ), f\"Expected sample #{i} {flat_sample} to be in {flat_space}\"\n@pytest.mark.parametrize(\"space\", spaces)\ndef test_flatten_dim(space):",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flatten_dim",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatten_dim(space):\n    sample = utils.flatten(space, space.sample())\n    (single_dim,) = sample.shape\n    flatdim = utils.flatdim(space)\n    assert single_dim == flatdim, f\"Expected {single_dim} to equal {flatdim}\"\n@pytest.mark.parametrize(\"space\", spaces)\ndef test_flatten_roundtripping(space):\n    some_samples = [space.sample() for _ in range(10)]\n    flattened_samples = [utils.flatten(space, sample) for sample in some_samples]\n    roundtripped_samples = [",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flatten_roundtripping",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatten_roundtripping(space):\n    some_samples = [space.sample() for _ in range(10)]\n    flattened_samples = [utils.flatten(space, sample) for sample in some_samples]\n    roundtripped_samples = [\n        utils.unflatten(space, sample) for sample in flattened_samples\n    ]\n    for i, (original, roundtripped) in enumerate(\n        zip(some_samples, roundtripped_samples)\n    ):\n        assert compare_nested(",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "compare_nested",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def compare_nested(left, right):\n    if isinstance(left, np.ndarray) and isinstance(right, np.ndarray):\n        return np.allclose(left, right)\n    elif isinstance(left, OrderedDict) and isinstance(right, OrderedDict):\n        res = len(left) == len(right)\n        for ((left_key, left_value), (right_key, right_value)) in zip(\n            left.items(), right.items()\n        ):\n            if not res:\n                return False",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_dtypes",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_dtypes(original_space, expected_flattened_dtype):\n    flattened_space = utils.flatten_space(original_space)\n    original_sample = original_space.sample()\n    flattened_sample = utils.flatten(original_space, original_sample)\n    unflattened_sample = utils.unflatten(original_space, flattened_sample)\n    assert flattened_space.contains(\n        flattened_sample\n    ), \"Expected flattened_space to contain flattened_sample\"\n    assert (\n        flattened_space.dtype == expected_flattened_dtype",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "compare_sample_types",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def compare_sample_types(original_space, original_sample, unflattened_sample):\n    if isinstance(original_space, Discrete):\n        assert isinstance(unflattened_sample, int), (\n            \"Expected unflattened_sample to be an int. unflattened_sample: \"\n            \"{} original_sample: {}\".format(unflattened_sample, original_sample)\n        )\n    elif isinstance(original_space, Tuple):\n        for index in range(len(original_space)):\n            compare_sample_types(\n                original_space.spaces[index],",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flatten",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatten(space, sample, expected_flattened_sample):\n    assert sample in space\n    flattened_sample = utils.flatten(space, sample)\n    assert flattened_sample.shape == expected_flattened_sample.shape\n    assert flattened_sample.dtype == expected_flattened_sample.dtype\n    assert np.all(flattened_sample == expected_flattened_sample)\n@pytest.mark.parametrize(\n    [\"space\", \"flattened_sample\", \"expected_sample\"],\n    zip(spaces, expected_flattened_samples, samples),\n)",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_unflatten",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_unflatten(space, flattened_sample, expected_sample):\n    sample = utils.unflatten(space, flattened_sample)\n    assert compare_nested(sample, expected_sample)\nexpected_flattened_spaces = [\n    Box(low=0, high=1, shape=(3,), dtype=np.int64),\n    Box(low=0.0, high=np.inf, shape=(4,), dtype=np.float32),\n    Box(low=0.0, high=np.inf, shape=(4,), dtype=np.float16),\n    Box(low=0, high=1, shape=(15,), dtype=np.int64),\n    Box(\n        low=np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], dtype=np.float64),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "test_flatten_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "def test_flatten_space(space, expected_flattened_space):\n    flattened_space = utils.flatten_space(space)\n    assert flattened_space == expected_flattened_space",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "spaces",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "spaces = [\n    Discrete(3),\n    Box(low=0.0, high=np.inf, shape=(2, 2)),\n    Box(low=0.0, high=np.inf, shape=(2, 2), dtype=np.float16),\n    Tuple([Discrete(5), Discrete(10)]),\n    Tuple(\n        [\n            Discrete(5),\n            Box(low=np.array([0.0, 0.0]), high=np.array([1.0, 5.0]), dtype=np.float64),\n        ]",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "flatdims",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "flatdims = [3, 4, 4, 15, 7, 9, 14, 10, 7, 3, 8]\n@pytest.mark.parametrize([\"space\", \"flatdim\"], zip(spaces, flatdims))\ndef test_flatdim(space, flatdim):\n    dim = utils.flatdim(space)\n    assert dim == flatdim, f\"Expected {dim} to equal {flatdim}\"\n@pytest.mark.parametrize(\"space\", spaces)\ndef test_flatten_space_boxes(space):\n    flat_space = utils.flatten_space(space)\n    assert isinstance(flat_space, Box), f\"Expected {type(flat_space)} to equal {Box}\"\n    flatdim = utils.flatdim(space)",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "expected_flattened_dtypes",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "expected_flattened_dtypes = [\n    np.int64,\n    np.float32,\n    np.float16,\n    np.int64,\n    np.float64,\n    np.int64,\n    np.int64,\n    np.int8,\n    np.float64,",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "samples",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "samples = [\n    2,\n    np.array([[1.0, 3.0], [5.0, 8.0]], dtype=np.float32),\n    np.array([[1.0, 3.0], [5.0, 8.0]], dtype=np.float16),\n    (3, 7),\n    (2, np.array([0.5, 3.5], dtype=np.float32)),\n    (3, 0, 1),\n    np.array([0, 1, 7], dtype=np.int64),\n    np.array([0, 1, 1, 0, 0, 0, 1, 1, 1, 1], dtype=np.int8),\n    OrderedDict(",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "expected_flattened_samples",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "expected_flattened_samples = [\n    np.array([0, 0, 1], dtype=np.int64),\n    np.array([1.0, 3.0, 5.0, 8.0], dtype=np.float32),\n    np.array([1.0, 3.0, 5.0, 8.0], dtype=np.float16),\n    np.array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], dtype=np.int64),\n    np.array([0, 0, 1, 0, 0, 0.5, 3.5], dtype=np.float64),\n    np.array([0, 0, 0, 1, 0, 1, 0, 0, 1], dtype=np.int64),\n    np.array([1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], dtype=np.int64),\n    np.array([0, 1, 1, 0, 0, 0, 1, 1, 1, 1], dtype=np.int8),\n    np.array([0, 0, 0, 1, 0, 0.5, 3.5], dtype=np.float64),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "expected_flattened_spaces",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "description": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "peekOfCode": "expected_flattened_spaces = [\n    Box(low=0, high=1, shape=(3,), dtype=np.int64),\n    Box(low=0.0, high=np.inf, shape=(4,), dtype=np.float32),\n    Box(low=0.0, high=np.inf, shape=(4,), dtype=np.float16),\n    Box(low=0, high=1, shape=(15,), dtype=np.int64),\n    Box(\n        low=np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], dtype=np.float64),\n        high=np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 5.0], dtype=np.float64),\n        dtype=np.float64,\n    ),",
        "detail": "repos_that_could_be_useful.gym.tests.spaces.test_utils",
        "documentation": {}
    },
    {
        "label": "ActionDictTestEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "peekOfCode": "class ActionDictTestEnv(gym.Env):\n    action_space = Dict({\"position\": Discrete(1), \"velocity\": Discrete(1)})\n    observation_space = Box(low=-1.0, high=2.0, shape=(3,), dtype=np.float32)\n    def step(self, action):\n        observation = np.array([1.0, 1.5, 0.5])\n        reward = 1\n        done = True\n        return observation, reward, done\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "documentation": {}
    },
    {
        "label": "test_check_env_dict_action",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "peekOfCode": "def test_check_env_dict_action():\n    # Environment.step() only returns 3 values: obs, reward, done. Not info!\n    test_env = ActionDictTestEnv()\n    with pytest.raises(AssertionError) as errorinfo:\n        check_env(env=test_env, warn=True)\n        assert (\n            str(errorinfo.value)\n            == \"The `step()` method must return four values: obs, reward, done, info\"\n        )",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_env_checker",
        "documentation": {}
    },
    {
        "label": "DummyEnvSpec",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "class DummyEnvSpec:\n    id: str\nclass DummyPlayEnv(gym.Env):\n    def step(self, action):\n        obs = np.zeros((1, 1))\n        rew, done, info = 1, False, {}\n        return obs, rew, done, info\n    def reset(self, seed=None):\n        ...\n    def render(self, mode=\"rgb_array\"):",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "DummyPlayEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "class DummyPlayEnv(gym.Env):\n    def step(self, action):\n        obs = np.zeros((1, 1))\n        rew, done, info = 1, False, {}\n        return obs, rew, done, info\n    def reset(self, seed=None):\n        ...\n    def render(self, mode=\"rgb_array\"):\n        return np.zeros((1, 1))\nclass PlayStatus:",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "PlayStatus",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "class PlayStatus:\n    def __init__(self, callback: Callable):\n        self.data_callback = callback\n        self.cumulative_reward = 0\n        self.last_observation = None\n    def callback(self, obs_t, obs_tp1, action, rew, done, info):\n        _, obs_tp1, _, rew, _, _ = self.data_callback(\n            obs_t, obs_tp1, action, rew, done, info\n        )\n        self.cumulative_reward += rew",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "dummy_keys_to_action",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def dummy_keys_to_action():\n    return {(RELEVANT_KEY_1,): 0, (RELEVANT_KEY_2,): 1}\n@pytest.fixture(autouse=True)\ndef close_pygame():\n    yield\n    pygame.quit()\ndef test_play_relevant_keys():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    assert game.relevant_keys == {RELEVANT_KEY_1, RELEVANT_KEY_2}",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "close_pygame",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def close_pygame():\n    yield\n    pygame.quit()\ndef test_play_relevant_keys():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    assert game.relevant_keys == {RELEVANT_KEY_1, RELEVANT_KEY_2}\ndef test_play_relevant_keys_no_mapping():\n    env = DummyPlayEnv()\n    env.spec = DummyEnvSpec(\"DummyPlayEnv\")",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_play_relevant_keys",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_play_relevant_keys():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    assert game.relevant_keys == {RELEVANT_KEY_1, RELEVANT_KEY_2}\ndef test_play_relevant_keys_no_mapping():\n    env = DummyPlayEnv()\n    env.spec = DummyEnvSpec(\"DummyPlayEnv\")\n    with pytest.raises(MissingKeysToAction):\n        PlayableGame(env)\ndef test_play_relevant_keys_with_env_attribute():",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_play_relevant_keys_no_mapping",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_play_relevant_keys_no_mapping():\n    env = DummyPlayEnv()\n    env.spec = DummyEnvSpec(\"DummyPlayEnv\")\n    with pytest.raises(MissingKeysToAction):\n        PlayableGame(env)\ndef test_play_relevant_keys_with_env_attribute():\n    \"\"\"Env has a keys_to_action attribute\"\"\"\n    env = DummyPlayEnv()\n    env.get_keys_to_action = dummy_keys_to_action\n    game = PlayableGame(env)",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_play_relevant_keys_with_env_attribute",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_play_relevant_keys_with_env_attribute():\n    \"\"\"Env has a keys_to_action attribute\"\"\"\n    env = DummyPlayEnv()\n    env.get_keys_to_action = dummy_keys_to_action\n    game = PlayableGame(env)\n    assert game.relevant_keys == {RELEVANT_KEY_1, RELEVANT_KEY_2}\ndef test_video_size_no_zoom():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    assert game.video_size == list(env.render().shape)",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_video_size_no_zoom",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_video_size_no_zoom():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    assert game.video_size == list(env.render().shape)\ndef test_video_size_zoom():\n    env = DummyPlayEnv()\n    zoom = 2.2\n    game = PlayableGame(env, dummy_keys_to_action(), zoom)\n    assert game.video_size == tuple(int(shape * zoom) for shape in env.render().shape)\ndef test_keyboard_quit_event():",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_video_size_zoom",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_video_size_zoom():\n    env = DummyPlayEnv()\n    zoom = 2.2\n    game = PlayableGame(env, dummy_keys_to_action(), zoom)\n    assert game.video_size == tuple(int(shape * zoom) for shape in env.render().shape)\ndef test_keyboard_quit_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": pygame.K_ESCAPE})\n    assert game.running is True",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_keyboard_quit_event",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_keyboard_quit_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": pygame.K_ESCAPE})\n    assert game.running is True\n    game.process_event(event)\n    assert game.running is False\ndef test_pygame_quit_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_pygame_quit_event",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_pygame_quit_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.QUIT)\n    assert game.running is True\n    game.process_event(event)\n    assert game.running is False\ndef test_keyboard_relevant_keydown_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_keyboard_relevant_keydown_event",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_keyboard_relevant_keydown_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": RELEVANT_KEY_1})\n    game.process_event(event)\n    assert game.pressed_keys == [RELEVANT_KEY_1]\ndef test_keyboard_irrelevant_keydown_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": IRRELEVANT_KEY})",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_keyboard_irrelevant_keydown_event",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_keyboard_irrelevant_keydown_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": IRRELEVANT_KEY})\n    game.process_event(event)\n    assert game.pressed_keys == []\ndef test_keyboard_keyup_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": RELEVANT_KEY_1})",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_keyboard_keyup_event",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_keyboard_keyup_event():\n    env = DummyPlayEnv()\n    game = PlayableGame(env, dummy_keys_to_action())\n    event = Event(pygame.KEYDOWN, {\"key\": RELEVANT_KEY_1})\n    game.process_event(event)\n    event = Event(pygame.KEYUP, {\"key\": RELEVANT_KEY_1})\n    game.process_event(event)\n    assert game.pressed_keys == []\ndef test_play_loop_real_env():\n    SEED = 42",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_play_loop_real_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "def test_play_loop_real_env():\n    SEED = 42\n    ENV = \"CartPole-v1\"\n    # set of key events to inject into the play loop as callback\n    callback_events = [\n        Event(KEYDOWN, {\"key\": RELEVANT_KEY_1}),\n        Event(KEYUP, {\"key\": RELEVANT_KEY_1}),\n        Event(KEYDOWN, {\"key\": RELEVANT_KEY_2}),\n        Event(KEYUP, {\"key\": RELEVANT_KEY_2}),\n        Event(KEYDOWN, {\"key\": RELEVANT_KEY_1}),",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "RELEVANT_KEY_1",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "RELEVANT_KEY_1 = ord(\"a\")  # 97\nRELEVANT_KEY_2 = ord(\"d\")  # 100\nIRRELEVANT_KEY = 1\n@dataclass\nclass DummyEnvSpec:\n    id: str\nclass DummyPlayEnv(gym.Env):\n    def step(self, action):\n        obs = np.zeros((1, 1))\n        rew, done, info = 1, False, {}",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "RELEVANT_KEY_2",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "RELEVANT_KEY_2 = ord(\"d\")  # 100\nIRRELEVANT_KEY = 1\n@dataclass\nclass DummyEnvSpec:\n    id: str\nclass DummyPlayEnv(gym.Env):\n    def step(self, action):\n        obs = np.zeros((1, 1))\n        rew, done, info = 1, False, {}\n        return obs, rew, done, info",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "IRRELEVANT_KEY",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "peekOfCode": "IRRELEVANT_KEY = 1\n@dataclass\nclass DummyEnvSpec:\n    id: str\nclass DummyPlayEnv(gym.Env):\n    def step(self, action):\n        obs = np.zeros((1, 1))\n        rew, done, info = 1, False, {}\n        return obs, rew, done, info\n    def reset(self, seed=None):",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_play",
        "documentation": {}
    },
    {
        "label": "test_invalid_seeds",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "peekOfCode": "def test_invalid_seeds():\n    for seed in [-1, \"test\"]:\n        try:\n            seeding.np_random(seed)\n        except error.Error:\n            pass\n        else:\n            assert False, f\"Invalid seed {seed} passed validation\"\ndef test_valid_seeds():\n    for seed in [0, 1]:",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "documentation": {}
    },
    {
        "label": "test_valid_seeds",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "peekOfCode": "def test_valid_seeds():\n    for seed in [0, 1]:\n        random, seed1 = seeding.np_random(seed)\n        assert seed == seed1\ndef test_rng_pickle():\n    rng, _ = seeding.np_random(seed=0)\n    pickled = pickle.dumps(rng)\n    rng2 = pickle.loads(pickled)\n    assert isinstance(\n        rng2, seeding.RandomNumberGenerator",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "documentation": {}
    },
    {
        "label": "test_rng_pickle",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "description": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "peekOfCode": "def test_rng_pickle():\n    rng, _ = seeding.np_random(seed=0)\n    pickled = pickle.dumps(rng)\n    rng2 = pickle.loads(pickled)\n    assert isinstance(\n        rng2, seeding.RandomNumberGenerator\n    ), \"Unpickled object is not a RandomNumberGenerator\"\n    assert rng.random() == rng2.random()",
        "detail": "repos_that_could_be_useful.gym.tests.utils.test_seeding",
        "documentation": {}
    },
    {
        "label": "test_create_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_create_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n    finally:\n        env.close()\n    assert env.num_envs == 8\n@pytest.mark.parametrize(\"shared_memory\", [True, False])\ndef test_reset_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_reset_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_reset_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        observations = env.reset()\n    finally:\n        env.close()\n    assert isinstance(env.observation_space, Box)\n    assert isinstance(observations, np.ndarray)\n    assert observations.dtype == env.observation_space.dtype",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_step_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_step_async_vector_env(shared_memory, use_single_action_space):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        observations = env.reset()\n        assert isinstance(env.single_action_space, Discrete)\n        assert isinstance(env.action_space, MultiDiscrete)\n        if use_single_action_space:\n            actions = [env.single_action_space.sample() for _ in range(8)]\n        else:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_call_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_call_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        _ = env.reset()\n        images = env.call(\"render\", mode=\"rgb_array\")\n        gravity = env.call(\"gravity\")\n    finally:\n        env.close()\n    assert isinstance(images, tuple)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_set_attr_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_set_attr_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        env.set_attr(\"gravity\", [9.81, 3.72, 8.87, 1.62])\n        gravity = env.get_attr(\"gravity\")\n        assert gravity == (9.81, 3.72, 8.87, 1.62)\n    finally:\n        env.close()\n@pytest.mark.parametrize(\"shared_memory\", [True, False])",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_copy_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_copy_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory, copy=True)\n        observations = env.reset()\n        observations[0] = 0\n    finally:\n        env.close()\n@pytest.mark.parametrize(\"shared_memory\", [True, False])\ndef test_no_copy_async_vector_env(shared_memory):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_no_copy_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_no_copy_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory, copy=False)\n        observations = env.reset()\n        observations[0] = 0\n    finally:\n        env.close()\n@pytest.mark.parametrize(\"shared_memory\", [True, False])\ndef test_reset_timeout_async_vector_env(shared_memory):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_reset_timeout_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_reset_timeout_async_vector_env(shared_memory):\n    env_fns = [make_slow_env(0.3, i) for i in range(4)]\n    with pytest.raises(TimeoutError):\n        try:\n            env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n            env.reset_async()\n            env.reset_wait(timeout=0.1)\n        finally:\n            env.close(terminate=True)\n@pytest.mark.parametrize(\"shared_memory\", [True, False])",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_step_timeout_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_step_timeout_async_vector_env(shared_memory):\n    env_fns = [make_slow_env(0.0, i) for i in range(4)]\n    with pytest.raises(TimeoutError):\n        try:\n            env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n            env.reset()\n            env.step_async([0.1, 0.1, 0.3, 0.1])\n            observations, rewards, dones, _ = env.step_wait(timeout=0.1)\n        finally:\n            env.close(terminate=True)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_reset_out_of_order_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_reset_out_of_order_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    with pytest.raises(NoAsyncCallError):\n        try:\n            env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n            env.reset_wait()\n        except NoAsyncCallError as exception:\n            assert exception.name == \"reset\"\n            raise\n        finally:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_step_out_of_order_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_step_out_of_order_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    with pytest.raises(NoAsyncCallError):\n        try:\n            env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n            actions = env.action_space.sample()\n            observations = env.reset()\n            observations, rewards, dones, infos = env.step_wait()\n        except AlreadyPendingCallError as exception:\n            assert exception.name == \"step\"",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_already_closed_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_already_closed_async_vector_env(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    with pytest.raises(ClosedEnvironmentError):\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        env.close()\n        env.reset()\n@pytest.mark.parametrize(\"shared_memory\", [True, False])\ndef test_check_spaces_async_vector_env(shared_memory):\n    # CartPole-v1 - observation_space: Box(4,), action_space: Discrete(2)\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_check_spaces_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_check_spaces_async_vector_env(shared_memory):\n    # CartPole-v1 - observation_space: Box(4,), action_space: Discrete(2)\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    # FrozenLake-v1 - Discrete(16), action_space: Discrete(4)\n    env_fns[1] = make_env(\"FrozenLake-v1\", 1)\n    with pytest.raises(RuntimeError):\n        env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        env.close(terminate=True)\ndef test_custom_space_async_vector_env():\n    env_fns = [make_custom_space_env(i) for i in range(4)]",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_custom_space_async_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_custom_space_async_vector_env():\n    env_fns = [make_custom_space_env(i) for i in range(4)]\n    try:\n        env = AsyncVectorEnv(env_fns, shared_memory=False)\n        reset_observations = env.reset()\n        assert isinstance(env.single_action_space, CustomSpace)\n        assert isinstance(env.action_space, Tuple)\n        actions = (\"action-2\", \"action-3\", \"action-5\", \"action-7\")\n        step_observations, rewards, dones, _ = env.step(actions)\n    finally:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_custom_space_async_vector_env_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "peekOfCode": "def test_custom_space_async_vector_env_shared_memory():\n    env_fns = [make_custom_space_env(i) for i in range(4)]\n    with pytest.raises(ValueError):\n        env = AsyncVectorEnv(env_fns, shared_memory=True)\n        env.close(terminate=True)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_async_vector_env",
        "documentation": {}
    },
    {
        "label": "test_concatenate",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "peekOfCode": "def test_concatenate(space):\n    def assert_type(lhs, rhs, n):\n        # Special case: if rhs is a list of scalars, lhs must be an np.ndarray\n        if np.isscalar(rhs[0]):\n            assert isinstance(lhs, np.ndarray)\n            assert all([np.isscalar(rhs[i]) for i in range(n)])\n        else:\n            assert all([isinstance(rhs[i], type(lhs)) for i in range(n)])\n    def assert_nested_equal(lhs, rhs, n):\n        assert isinstance(rhs, list)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "documentation": {}
    },
    {
        "label": "test_create_empty_array",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "peekOfCode": "def test_create_empty_array(space, n):\n    def assert_nested_type(arr, space, n):\n        if isinstance(space, _BaseGymSpaces):\n            assert isinstance(arr, np.ndarray)\n            assert arr.dtype == space.dtype\n            assert arr.shape == (n,) + space.shape\n        elif isinstance(space, Tuple):\n            assert isinstance(arr, tuple)\n            assert len(arr) == len(space.spaces)\n            for i in range(len(arr)):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "documentation": {}
    },
    {
        "label": "test_create_empty_array_zeros",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "peekOfCode": "def test_create_empty_array_zeros(space, n):\n    def assert_nested_type(arr, space, n):\n        if isinstance(space, _BaseGymSpaces):\n            assert isinstance(arr, np.ndarray)\n            assert arr.dtype == space.dtype\n            assert arr.shape == (n,) + space.shape\n            assert np.all(arr == 0)\n        elif isinstance(space, Tuple):\n            assert isinstance(arr, tuple)\n            assert len(arr) == len(space.spaces)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "documentation": {}
    },
    {
        "label": "test_create_empty_array_none_shape_ones",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "peekOfCode": "def test_create_empty_array_none_shape_ones(space):\n    def assert_nested_type(arr, space):\n        if isinstance(space, _BaseGymSpaces):\n            assert isinstance(arr, np.ndarray)\n            assert arr.dtype == space.dtype\n            assert arr.shape == space.shape\n            assert np.all(arr == 1)\n        elif isinstance(space, Tuple):\n            assert isinstance(arr, tuple)\n            assert len(arr) == len(space.spaces)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_numpy_utils",
        "documentation": {}
    },
    {
        "label": "test_create_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "peekOfCode": "def test_create_shared_memory(space, expected_type, n, ctx):\n    def assert_nested_type(lhs, rhs, n):\n        assert type(lhs) == type(rhs)\n        if isinstance(lhs, (list, tuple)):\n            assert len(lhs) == len(rhs)\n            for lhs_, rhs_ in zip(lhs, rhs):\n                assert_nested_type(lhs_, rhs_, n)\n        elif isinstance(lhs, (dict, OrderedDict)):\n            assert set(lhs.keys()) ^ set(rhs.keys()) == set()\n            for key in lhs.keys():",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "documentation": {}
    },
    {
        "label": "test_create_shared_memory_custom_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "peekOfCode": "def test_create_shared_memory_custom_space(n, ctx, space):\n    ctx = mp if (ctx is None) else mp.get_context(ctx)\n    with pytest.raises(CustomSpaceError):\n        create_shared_memory(space, n=n, ctx=ctx)\n@pytest.mark.parametrize(\n    \"space\", spaces, ids=[space.__class__.__name__ for space in spaces]\n)\ndef test_write_to_shared_memory(space):\n    def assert_nested_equal(lhs, rhs):\n        assert isinstance(rhs, list)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "documentation": {}
    },
    {
        "label": "test_write_to_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "peekOfCode": "def test_write_to_shared_memory(space):\n    def assert_nested_equal(lhs, rhs):\n        assert isinstance(rhs, list)\n        if isinstance(lhs, (list, tuple)):\n            for i in range(len(lhs)):\n                assert_nested_equal(lhs[i], [rhs_[i] for rhs_ in rhs])\n        elif isinstance(lhs, (dict, OrderedDict)):\n            for key in lhs.keys():\n                assert_nested_equal(lhs[key], [rhs_[key] for rhs_ in rhs])\n        elif isinstance(lhs, SynchronizedArray):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "documentation": {}
    },
    {
        "label": "test_read_from_shared_memory",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "peekOfCode": "def test_read_from_shared_memory(space):\n    def assert_nested_equal(lhs, rhs, space, n):\n        assert isinstance(rhs, list)\n        if isinstance(space, Tuple):\n            assert isinstance(lhs, tuple)\n            for i in range(len(lhs)):\n                assert_nested_equal(\n                    lhs[i], [rhs_[i] for rhs_ in rhs], space.spaces[i], n\n                )\n        elif isinstance(space, Dict):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "documentation": {}
    },
    {
        "label": "expected_types",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "peekOfCode": "expected_types = [\n    Array(\"d\", 1),\n    Array(\"f\", 1),\n    Array(\"f\", 3),\n    Array(\"f\", 4),\n    Array(\"B\", 1),\n    Array(\"B\", 32 * 32 * 3),\n    Array(\"i\", 1),\n    Array(\"i\", 1),\n    (Array(\"i\", 1), Array(\"i\", 1)),",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_shared_memory",
        "documentation": {}
    },
    {
        "label": "test_batch_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_batch_space(space, expected_batch_space_4):\n    batch_space_4 = batch_space(space, n=4)\n    assert batch_space_4 == expected_batch_space_4\n@pytest.mark.parametrize(\n    \"space,expected_batch_space_4\",\n    list(zip(custom_spaces, expected_custom_batch_spaces_4)),\n    ids=[space.__class__.__name__ for space in custom_spaces],\n)\ndef test_batch_space_custom_space(space, expected_batch_space_4):\n    batch_space_4 = batch_space(space, n=4)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_batch_space_custom_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_batch_space_custom_space(space, expected_batch_space_4):\n    batch_space_4 = batch_space(space, n=4)\n    assert batch_space_4 == expected_batch_space_4\n@pytest.mark.parametrize(\n    \"space,batch_space\",\n    list(zip(spaces, expected_batch_spaces_4)),\n    ids=[space.__class__.__name__ for space in spaces],\n)\ndef test_iterate(space, batch_space):\n    items = batch_space.sample()",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_iterate",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_iterate(space, batch_space):\n    items = batch_space.sample()\n    iterator = iterate(batch_space, items)\n    for i, item in enumerate(iterator):\n        assert item in space\n    assert i == 3\n@pytest.mark.parametrize(\n    \"space,batch_space\",\n    list(zip(custom_spaces, expected_custom_batch_spaces_4)),\n    ids=[space.__class__.__name__ for space in custom_spaces],",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_iterate_custom_space",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_iterate_custom_space(space, batch_space):\n    items = batch_space.sample()\n    iterator = iterate(batch_space, items)\n    for i, item in enumerate(iterator):\n        assert item in space\n    assert i == 3\n@pytest.mark.parametrize(\n    \"space\", spaces, ids=[space.__class__.__name__ for space in spaces]\n)\n@pytest.mark.parametrize(\"n\", [4, 5], ids=[f\"n={n}\" for n in [4, 5]])",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_rng_different_at_each_index",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_rng_different_at_each_index(space: Space, n: int, base_seed: int):\n    \"\"\"\n    Tests that the rng values produced at each index are different\n    to prevent if the rng is copied for each subspace\n    \"\"\"\n    space.seed(base_seed)\n    batched_space = batch_space(space, n)\n    assert space.np_random is not batched_space.np_random\n    assert_rng_equal(space.np_random, batched_space.np_random)\n    batched_sample = batched_space.sample()",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_deterministic",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "def test_deterministic(space: Space, n: int, base_seed: int):\n    \"\"\"Tests the batched spaces are deterministic by using a copied version\"\"\"\n    # Copy the spaces and check that the np_random are not reference equal\n    space_a = space\n    space_a.seed(base_seed)\n    space_b = copy.deepcopy(space_a)\n    assert_rng_equal(space_a.np_random, space_b.np_random)\n    assert space_a.np_random is not space_b.np_random\n    # Batch the spaces and check that the np_random are not reference equal\n    space_a_batched = batch_space(space_a, n)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "expected_batch_spaces_4",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "expected_batch_spaces_4 = [\n    Box(low=-1.0, high=1.0, shape=(4,), dtype=np.float64),\n    Box(low=0.0, high=10.0, shape=(4, 1), dtype=np.float64),\n    Box(\n        low=np.array(\n            [[-1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]\n        ),\n        high=np.array(\n            [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n        ),",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "expected_custom_batch_spaces_4",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "peekOfCode": "expected_custom_batch_spaces_4 = [\n    Tuple((CustomSpace(), CustomSpace(), CustomSpace(), CustomSpace())),\n    Tuple(\n        (\n            Tuple((CustomSpace(), CustomSpace(), CustomSpace(), CustomSpace())),\n            Box(low=0, high=255, shape=(4,), dtype=np.uint8),\n        )\n    ),\n]\n@pytest.mark.parametrize(",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_spaces",
        "documentation": {}
    },
    {
        "label": "test_create_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_create_sync_vector_env():\n    env_fns = [make_env(\"FrozenLake-v1\", i) for i in range(8)]\n    try:\n        env = SyncVectorEnv(env_fns)\n    finally:\n        env.close()\n    assert env.num_envs == 8\ndef test_reset_sync_vector_env():\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_reset_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_reset_sync_vector_env():\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    try:\n        env = SyncVectorEnv(env_fns)\n        observations = env.reset()\n    finally:\n        env.close()\n    assert isinstance(env.observation_space, Box)\n    assert isinstance(observations, np.ndarray)\n    assert observations.dtype == env.observation_space.dtype",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_step_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_step_sync_vector_env(use_single_action_space):\n    env_fns = [make_env(\"FrozenLake-v1\", i) for i in range(8)]\n    try:\n        env = SyncVectorEnv(env_fns)\n        observations = env.reset()\n        assert isinstance(env.single_action_space, Discrete)\n        assert isinstance(env.action_space, MultiDiscrete)\n        if use_single_action_space:\n            actions = [env.single_action_space.sample() for _ in range(8)]\n        else:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_call_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_call_sync_vector_env():\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    try:\n        env = SyncVectorEnv(env_fns)\n        _ = env.reset()\n        images = env.call(\"render\", mode=\"rgb_array\")\n        gravity = env.call(\"gravity\")\n    finally:\n        env.close()\n    assert isinstance(images, tuple)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_set_attr_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_set_attr_sync_vector_env():\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    try:\n        env = SyncVectorEnv(env_fns)\n        env.set_attr(\"gravity\", [9.81, 3.72, 8.87, 1.62])\n        gravity = env.get_attr(\"gravity\")\n        assert gravity == (9.81, 3.72, 8.87, 1.62)\n    finally:\n        env.close()\ndef test_check_spaces_sync_vector_env():",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_check_spaces_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_check_spaces_sync_vector_env():\n    # CartPole-v1 - observation_space: Box(4,), action_space: Discrete(2)\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(8)]\n    # FrozenLake-v1 - Discrete(16), action_space: Discrete(4)\n    env_fns[1] = make_env(\"FrozenLake-v1\", 1)\n    with pytest.raises(RuntimeError):\n        env = SyncVectorEnv(env_fns)\n        env.close()\ndef test_custom_space_sync_vector_env():\n    env_fns = [make_custom_space_env(i) for i in range(4)]",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_custom_space_sync_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_custom_space_sync_vector_env():\n    env_fns = [make_custom_space_env(i) for i in range(4)]\n    try:\n        env = SyncVectorEnv(env_fns)\n        reset_observations = env.reset()\n        assert isinstance(env.single_action_space, CustomSpace)\n        assert isinstance(env.action_space, Tuple)\n        actions = (\"action-2\", \"action-3\", \"action-5\", \"action-7\")\n        step_observations, rewards, dones, _ = env.step(actions)\n    finally:",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_sync_vector_env_seed",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_sync_vector_env_seed():\n    env = make_env(\"BipedalWalker-v3\", seed=123)()\n    sync_vector_env = SyncVectorEnv([make_env(\"BipedalWalker-v3\", seed=123)])\n    assert_rng_equal(env.action_space.np_random, sync_vector_env.action_space.np_random)\n    for _ in range(100):\n        env_action = env.action_space.sample()\n        vector_action = sync_vector_env.action_space.sample()\n        assert np.all(env_action == vector_action)\n@pytest.mark.parametrize(\"spec\", spec_list, ids=[spec.id for spec in spec_list])\ndef test_sync_vector_determinism(spec: EnvSpec, seed: int = 123, n: int = 3):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_sync_vector_determinism",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "peekOfCode": "def test_sync_vector_determinism(spec: EnvSpec, seed: int = 123, n: int = 3):\n    \"\"\"Check that for all environments, the sync vector envs produce the same action samples using the same seeds\"\"\"\n    env_1 = SyncVectorEnv([make_env(spec.id, seed=seed) for _ in range(n)])\n    env_2 = SyncVectorEnv([make_env(spec.id, seed=seed) for _ in range(n)])\n    assert_rng_equal(env_1.action_space.np_random, env_2.action_space.np_random)\n    for _ in range(100):\n        env_1_samples = env_1.action_space.sample()\n        env_2_samples = env_2.action_space.sample()\n        assert np.all(env_1_samples == env_2_samples)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_sync_vector_env",
        "documentation": {}
    },
    {
        "label": "test_vector_env_equal",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "peekOfCode": "def test_vector_env_equal(shared_memory):\n    env_fns = [make_env(\"CartPole-v1\", i) for i in range(4)]\n    num_steps = 100\n    try:\n        async_env = AsyncVectorEnv(env_fns, shared_memory=shared_memory)\n        sync_env = SyncVectorEnv(env_fns)\n        assert async_env.num_envs == sync_env.num_envs\n        assert async_env.observation_space == sync_env.observation_space\n        assert async_env.single_observation_space == sync_env.single_observation_space\n        assert async_env.action_space == sync_env.action_space",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "documentation": {}
    },
    {
        "label": "test_custom_space_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "peekOfCode": "def test_custom_space_vector_env():\n    env = VectorEnv(4, CustomSpace(), CustomSpace())\n    assert isinstance(env.single_observation_space, CustomSpace)\n    assert isinstance(env.observation_space, Tuple)\n    assert isinstance(env.single_action_space, CustomSpace)\n    assert isinstance(env.action_space, Tuple)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_vector_env",
        "documentation": {}
    },
    {
        "label": "DummyWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "peekOfCode": "class DummyWrapper(VectorEnvWrapper):\n    def __init__(self, env):\n        self.env = env\n        self.counter = 0\n    def reset_async(self, **kwargs):\n        super().reset_async()\n        self.counter += 1\ndef test_vector_env_wrapper_inheritance():\n    env = make(\"FrozenLake-v1\", asynchronous=False)\n    wrapped = DummyWrapper(env)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "documentation": {}
    },
    {
        "label": "test_vector_env_wrapper_inheritance",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "peekOfCode": "def test_vector_env_wrapper_inheritance():\n    env = make(\"FrozenLake-v1\", asynchronous=False)\n    wrapped = DummyWrapper(env)\n    wrapped.reset()\n    assert wrapped.counter == 1\ndef test_vector_env_wrapper_attributes():\n    \"\"\"Test if `set_attr`, `call` methods for VecEnvWrapper get correctly forwarded to the vector env it is wrapping.\"\"\"\n    env = make(\"CartPole-v1\", num_envs=3)\n    wrapped = DummyWrapper(make(\"CartPole-v1\", num_envs=3))\n    assert np.allclose(wrapped.call(\"gravity\"), env.call(\"gravity\"))",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "documentation": {}
    },
    {
        "label": "test_vector_env_wrapper_attributes",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "description": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "peekOfCode": "def test_vector_env_wrapper_attributes():\n    \"\"\"Test if `set_attr`, `call` methods for VecEnvWrapper get correctly forwarded to the vector env it is wrapping.\"\"\"\n    env = make(\"CartPole-v1\", num_envs=3)\n    wrapped = DummyWrapper(make(\"CartPole-v1\", num_envs=3))\n    assert np.allclose(wrapped.call(\"gravity\"), env.call(\"gravity\"))\n    env.set_attr(\"gravity\", [20.0, 20.0, 20.0])\n    wrapped.set_attr(\"gravity\", [20.0, 20.0, 20.0])\n    assert np.allclose(wrapped.get_attr(\"gravity\"), env.get_attr(\"gravity\"))",
        "detail": "repos_that_could_be_useful.gym.tests.vector.test_vector_env_wrapper",
        "documentation": {}
    },
    {
        "label": "UnittestSlowEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "class UnittestSlowEnv(gym.Env):\n    def __init__(self, slow_reset=0.3):\n        super().__init__()\n        self.slow_reset = slow_reset\n        self.observation_space = Box(\n            low=0, high=255, shape=(HEIGHT, WIDTH, 3), dtype=np.uint8\n        )\n        self.action_space = Box(low=0.0, high=1.0, shape=(), dtype=np.float32)\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "CustomSpace",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "class CustomSpace(gym.Space):\n    \"\"\"Minimal custom observation space.\"\"\"\n    def sample(self):\n        return self.np_random.integers(0, 10, ())\n    def contains(self, x):\n        return 0 <= x <= 10\n    def __eq__(self, other):\n        return isinstance(other, CustomSpace)\ncustom_spaces = [\n    CustomSpace(),",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "CustomSpaceEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "class CustomSpaceEnv(gym.Env):\n    def __init__(self):\n        super().__init__()\n        self.observation_space = CustomSpace()\n        self.action_space = CustomSpace()\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)\n        return \"reset\"\n    def step(self, action):\n        observation = f\"step({action:s})\"",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "def make_env(env_name, seed):\n    def _make():\n        env = gym.make(env_name)\n        env.action_space.seed(seed)\n        env.reset(seed=seed)\n        return env\n    return _make\ndef make_slow_env(slow_reset, seed):\n    def _make():\n        env = UnittestSlowEnv(slow_reset=slow_reset)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_slow_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "def make_slow_env(slow_reset, seed):\n    def _make():\n        env = UnittestSlowEnv(slow_reset=slow_reset)\n        env.reset(seed=seed)\n        return env\n    return _make\ndef make_custom_space_env(seed):\n    def _make():\n        env = CustomSpaceEnv()\n        env.reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "make_custom_space_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "def make_custom_space_env(seed):\n    def _make():\n        env = CustomSpaceEnv()\n        env.reset(seed=seed)\n        return env\n    return _make\ndef assert_rng_equal(rng_1: RandomNumberGenerator, rng_2: RandomNumberGenerator):\n    assert rng_1.bit_generator.state == rng_2.bit_generator.state",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "assert_rng_equal",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "def assert_rng_equal(rng_1: RandomNumberGenerator, rng_2: RandomNumberGenerator):\n    assert rng_1.bit_generator.state == rng_2.bit_generator.state",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "spaces",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "spaces = [\n    Box(low=np.array(-1.0), high=np.array(1.0), dtype=np.float64),\n    Box(low=np.array([0.0]), high=np.array([10.0]), dtype=np.float64),\n    Box(\n        low=np.array([-1.0, 0.0, 0.0]), high=np.array([1.0, 1.0, 1.0]), dtype=np.float64\n    ),\n    Box(\n        low=np.array([[-1.0, 0.0], [0.0, -1.0]]), high=np.ones((2, 2)), dtype=np.float64\n    ),\n    Box(low=0, high=255, shape=(), dtype=np.uint8),",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "custom_spaces",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.vector.utils",
        "description": "repos_that_could_be_useful.gym.tests.vector.utils",
        "peekOfCode": "custom_spaces = [\n    CustomSpace(),\n    Tuple((CustomSpace(), Box(low=0, high=255, shape=(), dtype=np.uint8))),\n]\nclass CustomSpaceEnv(gym.Env):\n    def __init__(self):\n        super().__init__()\n        self.observation_space = CustomSpace()\n        self.action_space = CustomSpace()\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):",
        "detail": "repos_that_could_be_useful.gym.tests.vector.utils",
        "documentation": {}
    },
    {
        "label": "FakeEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "peekOfCode": "class FakeEnvironment(gym.Env):\n    def __init__(self, observation_space):\n        self.observation_space = observation_space\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)\n        self.observation = self.observation_space.sample()\n        return self.observation\nOBSERVATION_SPACES = (\n    (\n        Dict(",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "documentation": {}
    },
    {
        "label": "TestFlattenEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "peekOfCode": "class TestFlattenEnvironment:\n    @pytest.mark.parametrize(\"observation_space, ordered_values\", OBSERVATION_SPACES)\n    def test_flattened_environment(self, observation_space, ordered_values):\n        \"\"\"\n        make sure that flattened observations occur in the order expected\n        \"\"\"\n        env = FakeEnvironment(observation_space=observation_space)\n        wrapped_env = FlattenObservation(env)\n        flattened = wrapped_env.reset()\n        unflattened = unflatten(env.observation_space, flattened)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "documentation": {}
    },
    {
        "label": "OBSERVATION_SPACES",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "peekOfCode": "OBSERVATION_SPACES = (\n    (\n        Dict(\n            OrderedDict(\n                [\n                    (\"key1\", Box(shape=(2, 3), low=0, high=0, dtype=np.float32)),\n                    (\"key2\", Box(shape=(), low=1, high=1, dtype=np.float32)),\n                    (\"key3\", Box(shape=(2,), low=2, high=2, dtype=np.float32)),\n                ]\n            )",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.flatten_test",
        "documentation": {}
    },
    {
        "label": "FakeEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "peekOfCode": "class FakeEnvironment(gym.Env):\n    def __init__(self, observation_space):\n        self.observation_space = observation_space\n        self.obs_keys = self.observation_space.spaces.keys()\n        self.action_space = Box(shape=(1,), low=-1, high=1, dtype=np.float32)\n    def render(self, width=32, height=32, *args, **kwargs):\n        del args\n        del kwargs\n        image_shape = (height, width, 3)\n        return np.zeros(image_shape, dtype=np.uint8)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "documentation": {}
    },
    {
        "label": "TestNestedDictWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "peekOfCode": "class TestNestedDictWrapper:\n    @pytest.mark.parametrize(\"observation_space, flat_shape\", NESTED_DICT_TEST_CASES)\n    def test_nested_dicts_size(self, observation_space, flat_shape):\n        env = FakeEnvironment(observation_space=observation_space)\n        # Make sure we are testing the right environment for the test.\n        observation_space = env.observation_space\n        assert isinstance(observation_space, Dict)\n        wrapped_env = FlattenObservation(FilterObservation(env, env.obs_keys))\n        assert wrapped_env.observation_space.shape == flat_shape\n        assert wrapped_env.observation_space.dtype == np.float32",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "documentation": {}
    },
    {
        "label": "NESTED_DICT_TEST_CASES",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "peekOfCode": "NESTED_DICT_TEST_CASES = (\n    (\n        Dict(\n            {\n                \"key1\": Box(shape=(2,), low=-1, high=1, dtype=np.float32),\n                \"key2\": Dict(\n                    {\n                        \"subkey1\": Box(shape=(2,), low=-1, high=1, dtype=np.float32),\n                        \"subkey2\": Box(shape=(2,), low=-1, high=1, dtype=np.float32),\n                    }",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.nested_dict_test",
        "documentation": {}
    },
    {
        "label": "env_fn",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "peekOfCode": "def env_fn():\n    return lambda: gym.make(\"PongNoFrameskip-v4\")\ndef test_atari_preprocessing_grayscale(env_fn):\n    import cv2\n    env1 = env_fn()\n    env2 = AtariPreprocessing(\n        env_fn(), screen_size=84, grayscale_obs=True, frame_skip=1, noop_max=0\n    )\n    env3 = AtariPreprocessing(\n        env_fn(), screen_size=84, grayscale_obs=False, frame_skip=1, noop_max=0",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "documentation": {}
    },
    {
        "label": "test_atari_preprocessing_grayscale",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "peekOfCode": "def test_atari_preprocessing_grayscale(env_fn):\n    import cv2\n    env1 = env_fn()\n    env2 = AtariPreprocessing(\n        env_fn(), screen_size=84, grayscale_obs=True, frame_skip=1, noop_max=0\n    )\n    env3 = AtariPreprocessing(\n        env_fn(), screen_size=84, grayscale_obs=False, frame_skip=1, noop_max=0\n    )\n    env4 = AtariPreprocessing(",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "documentation": {}
    },
    {
        "label": "test_atari_preprocessing_scale",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "peekOfCode": "def test_atari_preprocessing_scale(env_fn):\n    # arbitrarily chosen number for stepping into env. and ensuring all observations are in the required range\n    max_test_steps = 10\n    for grayscale in [True, False]:\n        for scaled in [True, False]:\n            env = AtariPreprocessing(\n                env_fn(),\n                screen_size=84,\n                grayscale_obs=grayscale,\n                scale_obs=scaled,",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_atari_preprocessing",
        "documentation": {}
    },
    {
        "label": "DummyResetEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "peekOfCode": "class DummyResetEnv(gym.Env):\n    \"\"\"A dummy environment which returns ascending numbers starting at `0` when :meth:`self.step()` is called.\n    After the second call to :meth:`self.step()` done is true.\n    Info dicts are also returned containing the same number returned as an observation, accessible via the key \"count\".\n    This environment is provided for the purpose of testing the autoreset wrapper.\n    \"\"\"\n    metadata = {}\n    def __init__(self):\n        \"\"\"Initialise the DummyResetEnv.\"\"\"\n        self.action_space = gym.spaces.Box(",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "documentation": {}
    },
    {
        "label": "unwrap_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "peekOfCode": "def unwrap_env(env) -> Generator[gym.Wrapper, None, None]:\n    \"\"\"Unwraps an environment yielding all wrappers around environment.\"\"\"\n    while isinstance(env, gym.Wrapper):\n        yield type(env)\n        env = env.env\n@pytest.mark.parametrize(\"spec\", spec_list, ids=[spec.id for spec in spec_list])\ndef test_make_autoreset_true(spec):\n    \"\"\"Tests gym.make with `autoreset=True`, and check that the reset actually happens.\n    Note: This test assumes that the outermost wrapper is AutoResetWrapper so if that\n     is being changed in the future, this test will break and need to be updated.",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "documentation": {}
    },
    {
        "label": "test_make_autoreset_true",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "peekOfCode": "def test_make_autoreset_true(spec):\n    \"\"\"Tests gym.make with `autoreset=True`, and check that the reset actually happens.\n    Note: This test assumes that the outermost wrapper is AutoResetWrapper so if that\n     is being changed in the future, this test will break and need to be updated.\n    Note: This test assumes that all first-party environments will terminate in a finite\n     amount of time with random actions, which is true as of the time of adding this test.\n    \"\"\"\n    with pytest.warns(None):\n        env = gym.make(spec.id, autoreset=True)\n    assert AutoResetWrapper in unwrap_env(env)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "documentation": {}
    },
    {
        "label": "test_gym_make_autoreset",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "peekOfCode": "def test_gym_make_autoreset(spec):\n    \"\"\"Tests that `gym.make` autoreset wrapper is applied only when `gym.make(..., autoreset=True)`.\"\"\"\n    with pytest.warns(None):\n        env = gym.make(spec.id)\n    assert AutoResetWrapper not in unwrap_env(env)\n    env.close()\n    with pytest.warns(None):\n        env = gym.make(spec.id, autoreset=False)\n    assert AutoResetWrapper not in unwrap_env(env)\n    env.close()",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "documentation": {}
    },
    {
        "label": "test_autoreset_wrapper_autoreset",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "peekOfCode": "def test_autoreset_wrapper_autoreset():\n    \"\"\"Tests the autoreset wrapper actually automatically resets correctly.\"\"\"\n    env = DummyResetEnv()\n    env = AutoResetWrapper(env)\n    obs, info = env.reset(return_info=True)\n    assert obs == np.array([0])\n    assert info == {\"count\": 0}\n    action = 0\n    obs, reward, done, info = env.step(action)\n    assert obs == np.array([1])",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_autoreset",
        "documentation": {}
    },
    {
        "label": "test_clip_action",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_clip_action",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_clip_action",
        "peekOfCode": "def test_clip_action():\n    # mountaincar: action-based rewards\n    env = gym.make(\"MountainCarContinuous-v0\")\n    wrapped_env = ClipAction(gym.make(\"MountainCarContinuous-v0\"))\n    seed = 0\n    env.reset(seed=seed)\n    wrapped_env.reset(seed=seed)\n    actions = [[0.4], [1.2], [-0.3], [0.0], [-2.5]]\n    for action in actions:\n        obs1, r1, d1, _ = env.step(",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_clip_action",
        "documentation": {}
    },
    {
        "label": "FakeEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "peekOfCode": "class FakeEnvironment(gym.Env):\n    def __init__(self, observation_keys=(\"state\")):\n        self.observation_space = spaces.Dict(\n            {\n                name: spaces.Box(shape=(2,), low=-1, high=1, dtype=np.float32)\n                for name in observation_keys\n            }\n        )\n        self.action_space = spaces.Box(shape=(1,), low=-1, high=1, dtype=np.float32)\n    def render(self, width=32, height=32, *args, **kwargs):",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "documentation": {}
    },
    {
        "label": "TestFilterObservation",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "peekOfCode": "class TestFilterObservation:\n    @pytest.mark.parametrize(\n        \"observation_keys,filter_keys\", FILTER_OBSERVATION_TEST_CASES\n    )\n    def test_filter_observation(self, observation_keys, filter_keys):\n        env = FakeEnvironment(observation_keys=observation_keys)\n        # Make sure we are testing the right environment for the test.\n        observation_space = env.observation_space\n        assert isinstance(observation_space, spaces.Dict)\n        wrapped_env = FilterObservation(env, filter_keys=filter_keys)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "documentation": {}
    },
    {
        "label": "FILTER_OBSERVATION_TEST_CASES",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "peekOfCode": "FILTER_OBSERVATION_TEST_CASES = (\n    ((\"key1\", \"key2\"), (\"key1\",)),\n    ((\"key1\", \"key2\"), (\"key1\", \"key2\")),\n    ((\"key1\",), None),\n    ((\"key1\",), (\"key1\",)),\n)\nERROR_TEST_CASES = (\n    (\"key\", ValueError, \"All the filter_keys must be included..*\"),\n    (False, TypeError, \"'bool' object is not iterable\"),\n    (1, TypeError, \"'int' object is not iterable\"),",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "documentation": {}
    },
    {
        "label": "ERROR_TEST_CASES",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "peekOfCode": "ERROR_TEST_CASES = (\n    (\"key\", ValueError, \"All the filter_keys must be included..*\"),\n    (False, TypeError, \"'bool' object is not iterable\"),\n    (1, TypeError, \"'int' object is not iterable\"),\n)\nclass TestFilterObservation:\n    @pytest.mark.parametrize(\n        \"observation_keys,filter_keys\", FILTER_OBSERVATION_TEST_CASES\n    )\n    def test_filter_observation(self, observation_keys, filter_keys):",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_filter_observation",
        "documentation": {}
    },
    {
        "label": "test_flatten_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_flatten_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_flatten_observation",
        "peekOfCode": "def test_flatten_observation(env_id):\n    env = gym.make(env_id)\n    wrapped_env = FlattenObservation(env)\n    obs = env.reset()\n    wrapped_obs = wrapped_env.reset()\n    space = spaces.Tuple((spaces.Discrete(32), spaces.Discrete(11), spaces.Discrete(2)))\n    wrapped_space = spaces.Box(0, 1, [32 + 11 + 2], dtype=np.int64)\n    assert space.contains(obs)\n    assert wrapped_space.contains(wrapped_obs)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_flatten_observation",
        "documentation": {}
    },
    {
        "label": "test_frame_stack",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_frame_stack",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_frame_stack",
        "peekOfCode": "def test_frame_stack(env_id, num_stack, lz4_compress):\n    env = gym.make(env_id)\n    shape = env.observation_space.shape\n    env = FrameStack(env, num_stack, lz4_compress)\n    assert env.observation_space.shape == (num_stack,) + shape\n    assert env.observation_space.dtype == env.env.observation_space.dtype\n    dup = gym.make(env_id)\n    obs = env.reset(seed=0)\n    dup_obs = dup.reset(seed=0)\n    assert np.allclose(obs[-1], dup_obs)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_frame_stack",
        "documentation": {}
    },
    {
        "label": "test_gray_scale_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_gray_scale_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_gray_scale_observation",
        "peekOfCode": "def test_gray_scale_observation(env_id, keep_dim):\n    gray_env = AtariPreprocessing(gym.make(env_id), screen_size=84, grayscale_obs=True)\n    rgb_env = AtariPreprocessing(gym.make(env_id), screen_size=84, grayscale_obs=False)\n    wrapped_env = GrayScaleObservation(rgb_env, keep_dim=keep_dim)\n    assert rgb_env.observation_space.shape[-1] == 3\n    seed = 0\n    gray_obs = gray_env.reset(seed=seed)\n    wrapped_obs = wrapped_env.reset(seed=seed)\n    if keep_dim:\n        assert wrapped_env.observation_space.shape[-1] == 1",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_gray_scale_observation",
        "documentation": {}
    },
    {
        "label": "DummyRewardEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "class DummyRewardEnv(gym.Env):\n    metadata = {}\n    def __init__(self, return_reward_idx=0):\n        self.action_space = gym.spaces.Discrete(2)\n        self.observation_space = gym.spaces.Box(\n            low=np.array([-1.0]), high=np.array([1.0]), dtype=np.float64\n        )\n        self.returned_rewards = [0, 1, 2, 3, 4]\n        self.return_reward_idx = return_reward_idx\n        self.t = self.return_reward_idx",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def make_env(return_reward_idx):\n    def thunk():\n        env = DummyRewardEnv(return_reward_idx)\n        return env\n    return thunk\n@pytest.mark.parametrize(\"return_info\", [False, True])\ndef test_normalize_observation(return_info: bool):\n    env = DummyRewardEnv(return_reward_idx=0)\n    env = NormalizeObservation(env)\n    env.reset(return_info=return_info)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_normalize_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def test_normalize_observation(return_info: bool):\n    env = DummyRewardEnv(return_reward_idx=0)\n    env = NormalizeObservation(env)\n    env.reset(return_info=return_info)\n    env.step(env.action_space.sample())\n    assert_almost_equal(env.obs_rms.mean, 0.5, decimal=4)\n    env.step(env.action_space.sample())\n    assert_almost_equal(env.obs_rms.mean, 1.0, decimal=4)\ndef test_normalize_reset_info():\n    env = DummyRewardEnv(return_reward_idx=0)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_normalize_reset_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def test_normalize_reset_info():\n    env = DummyRewardEnv(return_reward_idx=0)\n    env = NormalizeObservation(env)\n    obs = env.reset()\n    assert isinstance(obs, np.ndarray)\n    del obs\n    obs = env.reset(return_info=False)\n    assert isinstance(obs, np.ndarray)\n    del obs\n    obs, info = env.reset(return_info=True)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_normalize_return",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def test_normalize_return():\n    env = DummyRewardEnv(return_reward_idx=0)\n    env = NormalizeReward(env)\n    env.reset()\n    env.step(env.action_space.sample())\n    assert_almost_equal(\n        env.return_rms.mean,\n        np.mean([1]),  # [first return]\n        decimal=4,\n    )",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_normalize_observation_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def test_normalize_observation_vector_env():\n    env_fns = [make_env(0), make_env(1)]\n    envs = gym.vector.SyncVectorEnv(env_fns)\n    envs.reset()\n    obs, reward, _, _ = envs.step(envs.action_space.sample())\n    np.testing.assert_almost_equal(obs, np.array([[1], [2]]), decimal=4)\n    np.testing.assert_almost_equal(reward, np.array([1, 2]), decimal=4)\n    env_fns = [make_env(0), make_env(1)]\n    envs = gym.vector.SyncVectorEnv(env_fns)\n    envs = NormalizeObservation(envs)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_normalize_return_vector_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "peekOfCode": "def test_normalize_return_vector_env():\n    env_fns = [make_env(0), make_env(1)]\n    envs = gym.vector.SyncVectorEnv(env_fns)\n    envs = NormalizeReward(envs)\n    obs = envs.reset()\n    obs, reward, _, _ = envs.step(envs.action_space.sample())\n    assert_almost_equal(\n        envs.return_rms.mean,\n        np.mean([1.5]),  # the mean of first returns [[1, 2]]\n        decimal=4,",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_normalize",
        "documentation": {}
    },
    {
        "label": "test_order_enforcing_reset_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_order_enforcing",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_order_enforcing",
        "peekOfCode": "def test_order_enforcing_reset_info():\n    env = gym.make(\"CartPole-v1\")\n    env = OrderEnforcing(env)\n    ob_space = env.observation_space\n    obs = env.reset()\n    assert ob_space.contains(obs)\n    del obs\n    obs = env.reset(return_info=False)\n    assert ob_space.contains(obs)\n    del obs",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_order_enforcing",
        "documentation": {}
    },
    {
        "label": "FakeEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "peekOfCode": "class FakeEnvironment(gym.Env):\n    def __init__(self):\n        self.action_space = spaces.Box(shape=(1,), low=-1, high=1, dtype=np.float32)\n    def render(self, width=32, height=32, *args, **kwargs):\n        del args\n        del kwargs\n        image_shape = (height, width, 3)\n        return np.zeros(image_shape, dtype=np.uint8)\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "documentation": {}
    },
    {
        "label": "FakeArrayObservationEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "peekOfCode": "class FakeArrayObservationEnvironment(FakeEnvironment):\n    def __init__(self, *args, **kwargs):\n        self.observation_space = spaces.Box(\n            shape=(2,), low=-1, high=1, dtype=np.float32\n        )\n        super().__init__(*args, **kwargs)\nclass FakeDictObservationEnvironment(FakeEnvironment):\n    def __init__(self, *args, **kwargs):\n        self.observation_space = spaces.Dict(\n            {",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "documentation": {}
    },
    {
        "label": "FakeDictObservationEnvironment",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "peekOfCode": "class FakeDictObservationEnvironment(FakeEnvironment):\n    def __init__(self, *args, **kwargs):\n        self.observation_space = spaces.Dict(\n            {\n                \"state\": spaces.Box(shape=(2,), low=-1, high=1, dtype=np.float32),\n            }\n        )\n        super().__init__(*args, **kwargs)\nclass TestPixelObservationWrapper:\n    @pytest.mark.parametrize(\"pixels_only\", (True, False))",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "documentation": {}
    },
    {
        "label": "TestPixelObservationWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "peekOfCode": "class TestPixelObservationWrapper:\n    @pytest.mark.parametrize(\"pixels_only\", (True, False))\n    def test_dict_observation(self, pixels_only):\n        pixel_key = \"rgb\"\n        env = FakeDictObservationEnvironment()\n        # Make sure we are testing the right environment for the test.\n        observation_space = env.observation_space\n        assert isinstance(observation_space, spaces.Dict)\n        width, height = (320, 240)\n        # The wrapper should only add one observation.",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_pixel_observation",
        "documentation": {}
    },
    {
        "label": "test_record_episode_statistics",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "peekOfCode": "def test_record_episode_statistics(env_id, deque_size):\n    env = gym.make(env_id)\n    env = RecordEpisodeStatistics(env, deque_size)\n    for n in range(5):\n        env.reset()\n        assert env.episode_returns[0] == 0.0\n        assert env.episode_lengths[0] == 0\n        for t in range(env.spec.max_episode_steps):\n            _, _, done, info = env.step(env.action_space.sample())\n            if done:",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "documentation": {}
    },
    {
        "label": "test_record_episode_statistics_reset_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "peekOfCode": "def test_record_episode_statistics_reset_info():\n    env = gym.make(\"CartPole-v1\")\n    env = RecordEpisodeStatistics(env)\n    ob_space = env.observation_space\n    obs = env.reset()\n    assert ob_space.contains(obs)\n    del obs\n    obs, info = env.reset(return_info=True)\n    assert ob_space.contains(obs)\n    assert isinstance(info, dict)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "documentation": {}
    },
    {
        "label": "test_record_episode_statistics_with_vectorenv",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "peekOfCode": "def test_record_episode_statistics_with_vectorenv(num_envs, asynchronous):\n    envs = gym.vector.make(\"CartPole-v1\", num_envs=num_envs, asynchronous=asynchronous)\n    envs = RecordEpisodeStatistics(envs)\n    max_episode_step = (\n        envs.env_fns[0]().spec.max_episode_steps\n        if asynchronous\n        else envs.env.envs[0].spec.max_episode_steps\n    )\n    envs.reset()\n    for _ in range(max_episode_step + 1):",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_episode_statistics",
        "documentation": {}
    },
    {
        "label": "test_record_video_using_default_trigger",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "peekOfCode": "def test_record_video_using_default_trigger():\n    env = gym.make(\"CartPole-v1\")\n    env = gym.wrappers.RecordVideo(env, \"videos\")\n    env.reset()\n    for _ in range(199):\n        action = env.action_space.sample()\n        _, _, done, _ = env.step(action)\n        if done:\n            env.reset()\n    env.close()",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "documentation": {}
    },
    {
        "label": "test_record_video_reset_return_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "peekOfCode": "def test_record_video_reset_return_info():\n    env = gym.make(\"CartPole-v1\")\n    env = gym.wrappers.RecordVideo(env, \"videos\", step_trigger=lambda x: x % 100 == 0)\n    ob_space = env.observation_space\n    obs, info = env.reset(return_info=True)\n    env.close()\n    assert os.path.isdir(\"videos\")\n    shutil.rmtree(\"videos\")\n    assert ob_space.contains(obs)\n    assert isinstance(info, dict)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "documentation": {}
    },
    {
        "label": "test_record_video_step_trigger",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "peekOfCode": "def test_record_video_step_trigger():\n    env = gym.make(\"CartPole-v1\")\n    env._max_episode_steps = 20\n    env = gym.wrappers.RecordVideo(env, \"videos\", step_trigger=lambda x: x % 100 == 0)\n    env.reset()\n    for _ in range(199):\n        action = env.action_space.sample()\n        _, _, done, _ = env.step(action)\n        if done:\n            env.reset()",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "peekOfCode": "def make_env(gym_id, seed):\n    def thunk():\n        env = gym.make(gym_id)\n        env._max_episode_steps = 20\n        if seed == 1:\n            env = gym.wrappers.RecordVideo(\n                env, \"videos\", step_trigger=lambda x: x % 100 == 0\n            )\n        return env\n    return thunk",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "documentation": {}
    },
    {
        "label": "test_record_video_within_vector",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "peekOfCode": "def test_record_video_within_vector():\n    envs = gym.vector.SyncVectorEnv([make_env(\"CartPole-v1\", 1 + i) for i in range(2)])\n    envs = gym.wrappers.RecordEpisodeStatistics(envs)\n    envs.reset()\n    for i in range(199):\n        _, _, _, infos = envs.step(envs.action_space.sample())\n        for info in infos:\n            if \"episode\" in info.keys():\n                print(f\"episode_reward={info['episode']['r']}\")\n                break",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_record_video",
        "documentation": {}
    },
    {
        "label": "test_rescale_action",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_rescale_action",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_rescale_action",
        "peekOfCode": "def test_rescale_action():\n    env = gym.make(\"CartPole-v1\")\n    with pytest.raises(AssertionError):\n        env = RescaleAction(env, -1, 1)\n    del env\n    env = gym.make(\"Pendulum-v1\")\n    wrapped_env = RescaleAction(gym.make(\"Pendulum-v1\"), -1, 1)\n    seed = 0\n    obs = env.reset(seed=seed)\n    wrapped_obs = wrapped_env.reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_rescale_action",
        "documentation": {}
    },
    {
        "label": "test_resize_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_resize_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_resize_observation",
        "peekOfCode": "def test_resize_observation(env_id, shape):\n    env = gym.make(env_id)\n    env = ResizeObservation(env, shape)\n    assert env.observation_space.shape[-1] == 3\n    obs = env.reset()\n    if isinstance(shape, int):\n        assert env.observation_space.shape[:2] == (shape, shape)\n        assert obs.shape == (shape, shape, 3)\n    else:\n        assert env.observation_space.shape[:2] == tuple(shape)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_resize_observation",
        "documentation": {}
    },
    {
        "label": "test_time_aware_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_time_aware_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_time_aware_observation",
        "peekOfCode": "def test_time_aware_observation(env_id):\n    env = gym.make(env_id)\n    wrapped_env = TimeAwareObservation(env)\n    assert wrapped_env.observation_space.shape[0] == env.observation_space.shape[0] + 1\n    obs = env.reset()\n    wrapped_obs = wrapped_env.reset()\n    assert wrapped_env.t == 0.0\n    assert wrapped_obs[-1] == 0.0\n    assert wrapped_obs.shape[0] == obs.shape[0] + 1\n    wrapped_obs, _, _, _ = wrapped_env.step(env.action_space.sample())",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_time_aware_observation",
        "documentation": {}
    },
    {
        "label": "test_time_limit_reset_info",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_time_limit",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_time_limit",
        "peekOfCode": "def test_time_limit_reset_info():\n    env = gym.make(\"CartPole-v1\")\n    env = TimeLimit(env)\n    ob_space = env.observation_space\n    obs = env.reset()\n    assert ob_space.contains(obs)\n    del obs\n    obs = env.reset(return_info=False)\n    assert ob_space.contains(obs)\n    del obs",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_time_limit",
        "documentation": {}
    },
    {
        "label": "test_transform_observation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_observation",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_observation",
        "peekOfCode": "def test_transform_observation(env_id):\n    def affine_transform(x):\n        return 3 * x + 2\n    env = gym.make(env_id)\n    wrapped_env = TransformObservation(\n        gym.make(env_id), lambda obs: affine_transform(obs)\n    )\n    obs = env.reset(seed=0)\n    wrapped_obs = wrapped_env.reset(seed=0)\n    assert np.allclose(wrapped_obs, affine_transform(obs))",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_observation",
        "documentation": {}
    },
    {
        "label": "test_transform_reward",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_reward",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_reward",
        "peekOfCode": "def test_transform_reward(env_id):\n    # use case #1: scale\n    scales = [0.1, 200]\n    for scale in scales:\n        env = gym.make(env_id)\n        wrapped_env = TransformReward(gym.make(env_id), lambda r: scale * r)\n        action = env.action_space.sample()\n        env.reset(seed=0)\n        wrapped_env.reset(seed=0)\n        _, reward, _, _ = env.step(action)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_transform_reward",
        "documentation": {}
    },
    {
        "label": "BrokenRecordableEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "class BrokenRecordableEnv:\n    metadata = {\"render_modes\": [None, \"rgb_array\"]}\n    def render(self, mode=None):\n        pass\nclass UnrecordableEnv:\n    metadata = {\"render_modes\": [None]}\n    def render(self, mode=None):\n        pass\ndef test_record_simple():\n    env = gym.make(\"CartPole-v1\")",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "UnrecordableEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "class UnrecordableEnv:\n    metadata = {\"render_modes\": [None]}\n    def render(self, mode=None):\n        pass\ndef test_record_simple():\n    env = gym.make(\"CartPole-v1\")\n    rec = VideoRecorder(env)\n    env.reset()\n    rec.capture_frame()\n    proc = rec.encoder.proc",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_record_simple",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_record_simple():\n    env = gym.make(\"CartPole-v1\")\n    rec = VideoRecorder(env)\n    env.reset()\n    rec.capture_frame()\n    proc = rec.encoder.proc\n    assert proc.poll() is None  # subprocess is running\n    rec.close()\n    assert proc.poll() is not None  # subprocess is terminated\n    assert not rec.empty",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_autoclose",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_autoclose():\n    def record():\n        env = gym.make(\"CartPole-v1\")\n        rec = VideoRecorder(env)\n        env.reset()\n        rec.capture_frame()\n        rec_path = rec.path\n        proc = rec.encoder.proc\n        assert proc.poll() is None  # subprocess is running\n        # The function ends without an explicit `rec.close()` call",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_no_frames",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_no_frames():\n    env = BrokenRecordableEnv()\n    rec = VideoRecorder(env)\n    rec.close()\n    assert rec.empty\n    assert rec.functional\n    assert not os.path.exists(rec.path)\ndef test_record_unrecordable_method():\n    env = UnrecordableEnv()\n    rec = VideoRecorder(env)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_record_unrecordable_method",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_record_unrecordable_method():\n    env = UnrecordableEnv()\n    rec = VideoRecorder(env)\n    assert not rec.enabled\n    rec.close()\n@pytest.mark.filterwarnings(\"ignore:.*Env returned None on render.*\")\ndef test_record_breaking_render_method():\n    env = BrokenRecordableEnv()\n    rec = VideoRecorder(env)\n    rec.capture_frame()",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_record_breaking_render_method",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_record_breaking_render_method():\n    env = BrokenRecordableEnv()\n    rec = VideoRecorder(env)\n    rec.capture_frame()\n    rec.close()\n    assert rec.empty\n    assert rec.broken\n    assert not os.path.exists(rec.path)\ndef test_text_envs():\n    env = gym.make(\"FrozenLake-v1\")",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "test_text_envs",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "description": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "peekOfCode": "def test_text_envs():\n    env = gym.make(\"FrozenLake-v1\")\n    video = VideoRecorder(env)\n    try:\n        env.reset()\n        video.capture_frame()\n        video.close()\n    finally:\n        os.remove(video.path)",
        "detail": "repos_that_could_be_useful.gym.tests.wrappers.test_video_recorder",
        "documentation": {}
    },
    {
        "label": "ArgumentEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "class ArgumentEnv(core.Env):\n    calls = 0\n    def __init__(self, arg):\n        self.calls += 1\n        self.arg = arg\nclass UnittestEnv(core.Env):\n    observation_space = spaces.Box(low=0, high=255, shape=(64, 64, 3), dtype=np.uint8)\n    action_space = spaces.Discrete(3)\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "UnittestEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "class UnittestEnv(core.Env):\n    observation_space = spaces.Box(low=0, high=255, shape=(64, 64, 3), dtype=np.uint8)\n    action_space = spaces.Discrete(3)\n    def reset(self, *, seed: Optional[int] = None, options: Optional[dict] = None):\n        super().reset(seed=seed)\n        return self.observation_space.sample()  # Dummy observation\n    def step(self, action):\n        observation = self.observation_space.sample()  # Dummy observation\n        return (observation, 0.0, False, {})\nclass UnknownSpacesEnv(core.Env):",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "UnknownSpacesEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "class UnknownSpacesEnv(core.Env):\n    \"\"\"This environment defines its observation & action spaces only\n    after the first call to reset. Although this pattern is sometimes\n    necessary when implementing a new environment (e.g. if it depends\n    on external resources), it is not encouraged.\n    \"\"\"\n    def reset(\n        self,\n        *,\n        seed: Optional[int] = None,",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "OldStyleEnv",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "class OldStyleEnv(core.Env):\n    \"\"\"This environment doesn't accept any arguments in reset, ideally we want to support this too (for now)\"\"\"\n    def __init__(self):\n        pass\n    def reset(self):\n        super().reset()\n        return 0\n    def step(self, action):\n        return 0, 0, False, {}\nclass NewPropertyWrapper(core.Wrapper):",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "NewPropertyWrapper",
        "kind": 6,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "class NewPropertyWrapper(core.Wrapper):\n    def __init__(\n        self,\n        env,\n        observation_space=None,\n        action_space=None,\n        reward_range=None,\n        metadata=None,\n    ):\n        super().__init__(env)",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "test_env_instantiation",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "def test_env_instantiation():\n    # This looks like a pretty trivial, but given our usage of\n    # __new__, it's worth having.\n    env = ArgumentEnv(\"arg\")\n    assert env.arg == \"arg\"\n    assert env.calls == 1\nproperties = [\n    {\n        \"observation_space\": spaces.Box(\n            low=0.0, high=1.0, shape=(64, 64, 3), dtype=np.float32",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "test_wrapper_property_forwarding",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "def test_wrapper_property_forwarding(class_, props):\n    env = class_()\n    env = NewPropertyWrapper(env, **props)\n    # If UnknownSpacesEnv, then call reset to define the spaces\n    if isinstance(env.unwrapped, UnknownSpacesEnv):\n        _ = env.reset()\n    # Test the properties set by the wrapper\n    for key, value in props.items():\n        assert getattr(env, key) == value\n    # Otherwise, test if the properties are forwarded",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "test_compatibility_with_old_style_env",
        "kind": 2,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "def test_compatibility_with_old_style_env():\n    env = OldStyleEnv()\n    env = OrderEnforcing(env)\n    env = TimeLimit(env)\n    obs = env.reset()\n    assert obs == 0",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "properties",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.tests.test_core",
        "description": "repos_that_could_be_useful.gym.tests.test_core",
        "peekOfCode": "properties = [\n    {\n        \"observation_space\": spaces.Box(\n            low=0.0, high=1.0, shape=(64, 64, 3), dtype=np.float32\n        )\n    },\n    {\"action_space\": spaces.Discrete(2)},\n    {\"reward_range\": (-1.0, 1.0)},\n    {\"metadata\": {\"render_modes\": [\"human\", \"rgb_array\"]}},\n    {",
        "detail": "repos_that_could_be_useful.gym.tests.test_core",
        "documentation": {}
    },
    {
        "label": "extras",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "extras = {\n    \"atari\": [\"ale-py~=0.7.4\"],\n    \"accept-rom-license\": [\"autorom[accept-rom-license]~=0.4.2\"],\n    \"box2d\": [\"box2d-py==2.3.5\", \"pygame==2.1.0\"],\n    \"classic_control\": [\"pygame==2.1.0\"],\n    \"mujoco\": [\"mujoco_py>=1.50, <2.0\"],\n    \"toy_text\": [\"pygame==2.1.0\", \"scipy>=1.4.1\"],\n    \"other\": [\"lz4>=3.1.0\", \"opencv-python>=3.0\"],\n}\n# Meta dependency groups.",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "nomujoco_blacklist",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "nomujoco_blacklist = {\"mujoco\", \"accept-rom-license\", \"atari\"}\nnomujoco_groups = set(extras.keys()) - nomujoco_blacklist\nextras[\"nomujoco\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], nomujoco_groups))\n)\nall_blacklist = {\"accept-rom-license\"}\nall_groups = set(extras.keys()) - all_blacklist\nextras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "nomujoco_groups",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "nomujoco_groups = set(extras.keys()) - nomujoco_blacklist\nextras[\"nomujoco\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], nomujoco_groups))\n)\nall_blacklist = {\"accept-rom-license\"}\nall_groups = set(extras.keys()) - all_blacklist\nextras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)\nsetup(",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "extras[\"nomujoco\"]",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "extras[\"nomujoco\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], nomujoco_groups))\n)\nall_blacklist = {\"accept-rom-license\"}\nall_groups = set(extras.keys()) - all_blacklist\nextras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)\nsetup(\n    name=\"gym\",",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "all_blacklist",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "all_blacklist = {\"accept-rom-license\"}\nall_groups = set(extras.keys()) - all_blacklist\nextras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)\nsetup(\n    name=\"gym\",\n    version=VERSION,\n    description=\"Gym: A universal API for reinforcement learning environments\",\n    url=\"https://www.gymlibrary.ml/\",",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "all_groups",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "all_groups = set(extras.keys()) - all_blacklist\nextras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)\nsetup(\n    name=\"gym\",\n    version=VERSION,\n    description=\"Gym: A universal API for reinforcement learning environments\",\n    url=\"https://www.gymlibrary.ml/\",\n    author=\"Gym Community\",",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "extras[\"all\"]",
        "kind": 5,
        "importPath": "repos_that_could_be_useful.gym.setup",
        "description": "repos_that_could_be_useful.gym.setup",
        "peekOfCode": "extras[\"all\"] = list(\n    itertools.chain.from_iterable(map(lambda group: extras[group], all_groups))\n)\nsetup(\n    name=\"gym\",\n    version=VERSION,\n    description=\"Gym: A universal API for reinforcement learning environments\",\n    url=\"https://www.gymlibrary.ml/\",\n    author=\"Gym Community\",\n    author_email=\"jkterry@umd.edu\",",
        "detail": "repos_that_could_be_useful.gym.setup",
        "documentation": {}
    },
    {
        "label": "ObservationSpace",
        "kind": 6,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "class ObservationSpace:\n  Game_Area = [[0,0,0,0,0],\n                [0,0,0,0,0],\n                [0,0,1,0,0],\n                [0,0,0,0,0],\n                [0,0,0,0,0]]\n  Game_Name = \"GnomansLand\"\n  #Constructor\n  def __init__(self,Game_Name):\n      \"\"\"INITIALIZER",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "width",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "width = 800\nheight = 400\nscreen = pygame.display.set_mode((width,height)) # must be tuple\npygame.display.set_caption(\"Gnoman's Land\")\n#frame rate\n#maximum frame rate with clock\nclock = pygame.time.Clock() # capital c is important here\nw = 100\nh = 200\n#this creates a surface (unattached)",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "height",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "height = 400\nscreen = pygame.display.set_mode((width,height)) # must be tuple\npygame.display.set_caption(\"Gnoman's Land\")\n#frame rate\n#maximum frame rate with clock\nclock = pygame.time.Clock() # capital c is important here\nw = 100\nh = 200\n#this creates a surface (unattached)\ntest_surface = pygame.image.load('graphics/background.png')",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "screen = pygame.display.set_mode((width,height)) # must be tuple\npygame.display.set_caption(\"Gnoman's Land\")\n#frame rate\n#maximum frame rate with clock\nclock = pygame.time.Clock() # capital c is important here\nw = 100\nh = 200\n#this creates a surface (unattached)\ntest_surface = pygame.image.load('graphics/background.png')\n#!test_surface = pygame.Surface((w,h))",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "clock",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "clock = pygame.time.Clock() # capital c is important here\nw = 100\nh = 200\n#this creates a surface (unattached)\ntest_surface = pygame.image.load('graphics/background.png')\n#!test_surface = pygame.Surface((w,h))\n#!test_surface.fill('Red')\nwhile True:\n  for event in pygame.event.get(): # gets all possible player input events\n    if event.type == pygame.QUIT: # is constant that is 1 when x on window",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "w",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "w = 100\nh = 200\n#this creates a surface (unattached)\ntest_surface = pygame.image.load('graphics/background.png')\n#!test_surface = pygame.Surface((w,h))\n#!test_surface.fill('Red')\nwhile True:\n  for event in pygame.event.get(): # gets all possible player input events\n    if event.type == pygame.QUIT: # is constant that is 1 when x on window\n      pygame.quit() # opposite of pygame.init... once this is run we cannot display anything else anymore",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "h = 200\n#this creates a surface (unattached)\ntest_surface = pygame.image.load('graphics/background.png')\n#!test_surface = pygame.Surface((w,h))\n#!test_surface.fill('Red')\nwhile True:\n  for event in pygame.event.get(): # gets all possible player input events\n    if event.type == pygame.QUIT: # is constant that is 1 when x on window\n      pygame.quit() # opposite of pygame.init... once this is run we cannot display anything else anymore\n      exit() # will exit the while true loop and not hit line 59",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "test_surface",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "test_surface = pygame.image.load('graphics/background.png')\n#!test_surface = pygame.Surface((w,h))\n#!test_surface.fill('Red')\nwhile True:\n  for event in pygame.event.get(): # gets all possible player input events\n    if event.type == pygame.QUIT: # is constant that is 1 when x on window\n      pygame.quit() # opposite of pygame.init... once this is run we cannot display anything else anymore\n      exit() # will exit the while true loop and not hit line 59\n  position = (0,0)\n  screen.blit(test_surface,position)",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "#!test_surface",
        "kind": 5,
        "importPath": "src.environment",
        "description": "src.environment",
        "peekOfCode": "#!test_surface = pygame.Surface((w,h))\n#!test_surface.fill('Red')\nwhile True:\n  for event in pygame.event.get(): # gets all possible player input events\n    if event.type == pygame.QUIT: # is constant that is 1 when x on window\n      pygame.quit() # opposite of pygame.init... once this is run we cannot display anything else anymore\n      exit() # will exit the while true loop and not hit line 59\n  position = (0,0)\n  screen.blit(test_surface,position)\n  #will run forever",
        "detail": "src.environment",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "src.gnome_basic",
        "description": "src.gnome_basic",
        "peekOfCode": "class Agent:\n    voice = \"Hey... I'm Greg...\" # an example of something the agent could say.\n    health = 100 # setting their initial health to 100.\n    mood = 0 # the agent has absolutely no mood at all when they are born.\n    interest = 0 # starts with no interest at all in features within his/her/their action space.\n    strength = 50 # ranges from 1 to 100 and will change based on interactions with environment.\n    agent_name = \"Greg\" # the name of the agent (will change)\n    xlocation = 2 # ranges\n    # call gamearea len(gamearea)//2 gives the central point if it is an odd number of cols or rows\n    ylocation = 2 # ranges",
        "detail": "src.gnome_basic",
        "documentation": {}
    },
    {
        "label": "Pet",
        "kind": 6,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "class Pet:\n    '''Docstring'''\n    def __init__(self, name: str, animal: str):\n        '''Docstring'''\n        self.name = name\n        self.animal = animal\n    def who_am_i(self: \"Pet\") -> None:\n        '''Docstring'''\n        print(\"\\n\"+self.name+\" is a \"+self.animal+\"\\n\\n\")\npet1: Pet = Pet(\"Scooby\", \"Dog\")",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "class State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state\n        self.isEnd = False\n        self.determine = DETERMINISTIC\n    def giveReward(self):\n        if self.state == WIN_STATE:\n            return 1",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "class Agent:\n    def __init__(self):\n        self.states = []\n        self.actions = [\"up\", \"down\", \"left\", \"right\"]\n        self.State = State()\n        self.lr = 0.2\n        self.exp_rate = 0.3\n        # initial state reward\n        self.state_values = {}\n        for i in range(BOARD_ROWS):",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "BOARD_ROWS",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "BOARD_ROWS = 100\nBOARD_COLS = 100\nWIN_STATE = (27, 26)\nLOSE_STATE = (27, 25)\nSTART = (0, 0)\nDETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "BOARD_COLS",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "BOARD_COLS = 100\nWIN_STATE = (27, 26)\nLOSE_STATE = (27, 25)\nSTART = (0, 0)\nDETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "WIN_STATE",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "WIN_STATE = (27, 26)\nLOSE_STATE = (27, 25)\nSTART = (0, 0)\nDETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state\n        self.isEnd = False",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "LOSE_STATE",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "LOSE_STATE = (27, 25)\nSTART = (0, 0)\nDETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state\n        self.isEnd = False\n        self.determine = DETERMINISTIC",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "START",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "START = (0, 0)\nDETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state\n        self.isEnd = False\n        self.determine = DETERMINISTIC\n    def giveReward(self):",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "DETERMINISTIC",
        "kind": 5,
        "importPath": "src.rules_and_requirements",
        "description": "src.rules_and_requirements",
        "peekOfCode": "DETERMINISTIC = True\nclass State:\n    def __init__(self, state=START):\n        self.board = np.zeros([BOARD_ROWS, BOARD_COLS])\n        self.board[1, 1] = -1\n        self.state = state\n        self.isEnd = False\n        self.determine = DETERMINISTIC\n    def giveReward(self):\n        if self.state == WIN_STATE:",
        "detail": "src.rules_and_requirements",
        "documentation": {}
    },
    {
        "label": "MyClass",
        "kind": 6,
        "importPath": "tests.test_sth",
        "description": "tests.test_sth",
        "peekOfCode": "class MyClass:\n    x = 5\np1: MyClass = MyClass()\nprint(p1.x)\n#\nx: int = 1\ndef test_1() -> None:\n    assert 1 == 1\ndef test_2() -> None:\n    assert demo_variable_imported_from_module == \"Hello! I come from the module 'module_example.py'\"",
        "detail": "tests.test_sth",
        "documentation": {}
    },
    {
        "label": "test_1",
        "kind": 2,
        "importPath": "tests.test_sth",
        "description": "tests.test_sth",
        "peekOfCode": "def test_1() -> None:\n    assert 1 == 1\ndef test_2() -> None:\n    assert demo_variable_imported_from_module == \"Hello! I come from the module 'module_example.py'\"",
        "detail": "tests.test_sth",
        "documentation": {}
    },
    {
        "label": "test_2",
        "kind": 2,
        "importPath": "tests.test_sth",
        "description": "tests.test_sth",
        "peekOfCode": "def test_2() -> None:\n    assert demo_variable_imported_from_module == \"Hello! I come from the module 'module_example.py'\"",
        "detail": "tests.test_sth",
        "documentation": {}
    }
]